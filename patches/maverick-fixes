*** ./ivtools-1.2/config/site.def.DARWIN.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/config/site.def.DARWIN	2015-01-24 11:26:33.000000000 -0800
***************
*** 28,40 ****
   * build RPC classes -- requires iostreams & TCP sockets
   */
  #undef BuildRPCClasses
! #define BuildRPCClasses (YES&&!LibStdCPlusPlusV3)
  #define SOMAXCONN 5
  
  /* override -ansi -pedantic from xfree86.cf */
  /* use ucontext routines */
  #undef DefaultCCOptions
! #define DefaultCCOptions -fno-common -D_XOPEN_SOURCE
  
  /* machine-specific gcc include directory -- does not change with each new version of gcc */
  #if 0
--- 28,41 ----
   * build RPC classes -- requires iostreams & TCP sockets
   */
  #undef BuildRPCClasses
! /* #define BuildRPCClasses (YES&&!LibStdCPlusPlusV3) */
! #define BuildRPCClasses NO
  #define SOMAXCONN 5
  
  /* override -ansi -pedantic from xfree86.cf */
  /* use ucontext routines */
  #undef DefaultCCOptions
! #define DefaultCCOptions -fno-common -D_XOPEN_SOURCE -x c++
  
  /* machine-specific gcc include directory -- does not change with each new version of gcc */
  #if 0
***************
*** 59,65 ****
  #if 0
  #define SharedLibraryCmd(ldobjs,extra_flags) $(LD) -r extra_flags -o $@~ ldobjs
  #else
! #define SharedLibraryCmdDarwin(ldobjs,depobjs,rev,libname) CCDriver -dynamiclib -install_name @PREFIX@/lib/$(AOUT) -current_version rev -compatibility_version rev -o $@~ ldobjs depobjs -flat_namespace -undefined suppress
  #endif
  
  #define NormalDynamicSharedLibraryTarget(libname,rev,depobjs,ldobjs)	@@\
--- 60,66 ----
  #if 0
  #define SharedLibraryCmd(ldobjs,extra_flags) $(LD) -r extra_flags -o $@~ ldobjs
  #else
! #define SharedLibraryCmdDarwin(ldobjs,depobjs,rev,libname) CCDriver -dynamiclib -install_name Prefix/lib/$(AOUT) -current_version rev -compatibility_version rev -o $@~ ldobjs depobjs -flat_namespace -undefined suppress
  #endif
  
  #define NormalDynamicSharedLibraryTarget(libname,rev,depobjs,ldobjs)	@@\
*** ./ivtools-1.2/configure.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/configure	2015-01-18 22:22:41.000000000 -0800
***************
*** 3586,3591 ****
--- 3586,3593 ----
  # Standard set of common directories for X headers.
  # Check X11 before X11Rn because it is often a symlink to the current release.
  ac_x_header_dirs='
+ /opt/X11/include
+ 
  /usr/X11/include
  /usr/X11R6/include
  /usr/X11R5/include
***************
*** 3719,3725 ****
  for ac_dir in `echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
  do
    # Don't even attempt the hair of trying to link an X program!
!   for ac_extension in a so sl; do
      if test -r $ac_dir/libXt.$ac_extension; then
        ac_x_libraries=$ac_dir
        break 2
--- 3721,3727 ----
  for ac_dir in `echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
  do
    # Don't even attempt the hair of trying to link an X program!
!   for ac_extension in a so sl dylib; do
      if test -r $ac_dir/libXt.$ac_extension; then
        ac_x_libraries=$ac_dir
        break 2
*** ./ivtools-1.2/MANIFEST.comterp.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/MANIFEST.comterp	2015-01-25 17:31:18.000000000 -0800
***************
*** 283,288 ****
--- 283,289 ----
  src/include/Unidraw/umap.h
  src/include/Unidraw/unidraw.h
  src/include/ivstd/Imakefile
+ src/include/ivstd/fstream
  src/include/ivstd/fstream.h
  src/include/ivstd/iosfwd
  src/include/ivstd/math.h
*** ./ivtools-1.2/MANIFEST.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/MANIFEST	2015-01-25 17:30:51.000000000 -0800
***************
*** 1584,1589 ****
--- 1584,1590 ----
  ivtools-1.2/src/include/Unidraw/viewer.h
  ivtools-1.2/src/include/ivstd/Imakefile
  ivtools-1.2/src/include/ivstd/Makefile
+ ivtools-1.2/src/include/ivstd/fstream
  ivtools-1.2/src/include/ivstd/fstream.h
  ivtools-1.2/src/include/ivstd/iosfwd
  ivtools-1.2/src/include/ivstd/iostream.h
*** ./ivtools-1.2/src/comdraw/main.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/comdraw/main.c	2015-01-25 18:28:22.000000000 -0800
***************
*** 298,306 ****
--- 298,308 ----
      // Register COMTERP_QUIT_HANDLER to receive SIGINT commands.  When received,
      // COMTERP_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
+ #if 0
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, COMTERP_QUIT_HANDLER::instance ()) == -1)
          cerr << "comdraw:  unable to register quit handler with ACE reactor\n";
+ #endif
  
  #endif
      int exit_status = 0;
*** ./ivtools-1.2/src/ComTerp/comhandler.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/comhandler.c	2015-01-25 17:08:57.000000000 -0800
***************
*** 26,36 ****
  #ifdef HAVE_ACE
  #include <iostream.h>
  #include <fstream.h>
- #if __GNUC__==2 && __GNUC_MINOR__<=7
- #else
  using namespace std;
  #include <vector>
- #endif
  
  #include <ComTerp/comhandler.h>
  #include <ComTerp/comterpserv.h>
--- 26,33 ----
***************
*** 140,150 ****
  	    return -1;
  	} else {
  	    if (!comterp_->stack_empty()) {
! #if __GNUC__<3
! 	      filebuf obuf(1);
! #else
! 	      fileptr_filebuf obuf(stdout, ios_base::out);
! #endif
  	      ostream ostr(&obuf);
  	      ostr << "timeexpr result:  ";
  	      comterp_->print_stack_top(ostr);
--- 137,143 ----
  	    return -1;
  	} else {
  	    if (!comterp_->stack_empty()) {
! 	      FILEBUF(obuf, stdout, ios_base::out);
  	      ostream ostr(&obuf);
  	      ostr << "timeexpr result:  ";
  	      comterp_->print_stack_top(ostr);
***************
*** 206,212 ****
      } else {
        if (inbuf[0]!='\004')
  	cout << "from pipe(" << fd << "):  " << inbuf << "\n";
!       fileptr_filebuf obuf(fd ? wrfptr() : stdout, ios_base::out);
        ostream ostr(&obuf);
        ostr << "\n";
        ostr.flush();
--- 199,205 ----
      } else {
        if (inbuf[0]!='\004')
  	cout << "from pipe(" << fd << "):  " << inbuf << "\n";
!       FILEBUF(obuf, fd ? wrfptr() : stdout, ios_base::out);
        ostream ostr(&obuf);
        ostr << "\n";
        ostr.flush();
*** ./ivtools-1.2/src/ComTerp/comterp.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/comterp.c	2015-01-25 17:29:43.000000000 -0800
***************
*** 29,37 ****
  #include <strstream>
  #include <unistd.h>
  
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  #include <ComTerp/comhandler.h>
  
--- 29,35 ----
***************
*** 72,80 ****
  #include <string.h>
  #include <strstream>
  #include <unistd.h>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  #ifdef LEAKCHECK
  #include <leakchecker.h>
--- 70,76 ----
***************
*** 346,354 ****
      }
  
      if (stepflag()) {
!       fileptr_filebuf fbufout(handler() && handler()->wrfptr() 
! 		      ? handler()->wrfptr() : stdout, 
! 		      ios_base::out);
        ostream out(&fbufout);
        out << ">>> " << *func << "(" << *func->funcstate() << ")\n";
        static int pause_symid = symbol_add("pause");
--- 342,348 ----
      }
  
      if (stepflag()) {
!       FILEBUF(fbufout, handler() && handler()->wrfptr() ? handler()->wrfptr() : stdout, ios_base::out);
        ostream out(&fbufout);
        out << ">>> " << *func << "(" << *func->funcstate() << ")\n";
        static int pause_symid = symbol_add("pause");
***************
*** 1071,1092 ****
    char errbuf_save[BUFSIZ];
    errbuf_save[0] = '\0';
  
! #if __GNUC__<3
!   filebuf fbuf;
!   if (handler()) {
!     int fd = Math::max(1, handler()->get_handle());
!     fbuf.attach(fd);
!   } else
!     fbuf.attach(fileno(stdout));
! #elif (__GNUC__==3 && __GNUC_MINOR__<1) || __GNUC__>3 || defined(__CYGWIN__)
!   fileptr_filebuf fbuf(handler() && handler()->wrfptr() 
! 		       ? handler()->wrfptr() : (_fd>0 ? fdopen(_fd, "w") : stdout), 
! 	       ios_base::out);
! #else
!   fileptr_filebuf fbuf(handler()&&handler()->get_handle()>0 
! 		       ? handler()->get_handle() : 1, 
! 		       ios_base::out, false, static_cast<size_t>(BUFSIZ));
! #endif
    ostream out(&fbuf);
    boolean eolflag = false;
    boolean errorflag = false;
--- 1065,1071 ----
    char errbuf_save[BUFSIZ];
    errbuf_save[0] = '\0';
  
!   FILEBUF(fbuf, handler() && handler()->wrfptr() ? handler()->wrfptr() : (_fd>0 ? fdopen(_fd, "w") : stdout), ios_base::out);
    ostream out(&fbuf);
    boolean eolflag = false;
    boolean errorflag = false;
***************
*** 1358,1364 ****
  	if (read_expr()) {
  	    if (eval_expr(true)) {
  	        err_print( stderr, "comterp" );
! 	        fileptr_filebuf obuf(stdout, ios_base::out);
  		ostream ostr(&obuf);
  		ostr << "err\n";
  		ostr.flush();
--- 1337,1343 ----
  	if (read_expr()) {
  	    if (eval_expr(true)) {
  	        err_print( stderr, "comterp" );
! 		FILEBUF(obuf, stdout, ios_base::out);
  		ostream ostr(&obuf);
  		ostr << "err\n";
  		ostr.flush();
***************
*** 1672,1679 ****
  
  void ComTerp::postfix_echo(postfix_token* pfbuf, int pfnum) {
    // print everything in the pfbuf for this function
!   fileptr_filebuf fbuf(handler() && handler()->wrfptr()
! 	       ? handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbuf);
   
    boolean oldbrief = brief();
--- 1651,1657 ----
  
  void ComTerp::postfix_echo(postfix_token* pfbuf, int pfnum) {
    // print everything in the pfbuf for this function
!   FILEBUF(fbuf,handler() && handler()->wrfptr() ? handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbuf);
   
    boolean oldbrief = brief();
*** ./ivtools-1.2/src/ComTerp/comterpserv.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/comterpserv.c	2015-01-25 16:49:11.000000000 -0800
***************
*** 32,40 ****
  #include <OS/math.h>
  #include <iostream.h>
  #include <string.h>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  #if BUFSIZ>1024
  #undef BUFSIZ
--- 32,38 ----
***************
*** 194,200 ****
      int fd = Math::max(server->_fd, 1);
      char instr[BUFSIZ];
      FILE* ifptr = fd==0 ? stdin : server->handler()->rdfptr();
!     fileptr_filebuf fbuf(ifptr, ios_base::in);
      istream in (&fbuf);
      in.get(instr, BUFSIZ, '\n');  // needs to be generalized with <vector.h>
      server->_instat = in.good(); 
--- 192,198 ----
      int fd = Math::max(server->_fd, 1);
      char instr[BUFSIZ];
      FILE* ifptr = fd==0 ? stdin : server->handler()->rdfptr();
!     FILEBUF(fbuf, ifptr, ios_base::in);
      istream in (&fbuf);
      in.get(instr, BUFSIZ, '\n');  // needs to be generalized with <vector.h>
      server->_instat = in.good(); 
***************
*** 229,235 ****
  
      int fd = (int)server->_fd;
      FILE* ofptr = fd==1 ? stdout : server->handler()->wrfptr();
!     fileptr_filebuf fbuf(ofptr, ios_base::out);
      ostream out(&fbuf);
      for (; outpos < bufsize-1 && s[outpos]; outpos++)
  	out.put(s[outpos]);
--- 227,233 ----
  
      int fd = (int)server->_fd;
      FILE* ofptr = fd==1 ? stdout : server->handler()->wrfptr();
!     FILEBUF(fbuf, ofptr, ios_base::out);
      ostream out(&fbuf);
      for (; outpos < bufsize-1 && s[outpos]; outpos++)
  	out.put(s[outpos]);
***************
*** 284,290 ****
        pop_servstate();
        return -1;
      }
!     fileptr_filebuf ibuf(ifptr, ios_base::in);
      istream istr(&ibuf);
      ComValue* retval = nil;
      int status = 0;
--- 282,288 ----
        pop_servstate();
        return -1;
      }
!     FILEBUF(ibuf, ifptr, ios_base::in);
      istream istr(&ibuf);
      ComValue* retval = nil;
      int status = 0;
***************
*** 334,340 ****
  	        snprintf(buf, BUFSIZ, "comterp(%s)", filename);
  	        err_print( stderr, buf );
                  FILE* ofptr = handler() ? handler()->wrfptr() : stdout; 
! 	        fileptr_filebuf obuf(ofptr, ios_base::out);
  		ostream ostr(&obuf);
  		ostr.flush();
  		status = -1;
--- 332,338 ----
  	        snprintf(buf, BUFSIZ, "comterp(%s)", filename);
  	        err_print( stderr, buf );
                  FILE* ofptr = handler() ? handler()->wrfptr() : stdout; 
! 	        FILEBUF(obuf, ofptr, ios_base::out);
  		ostream ostr(&obuf);
  		ostr.flush();
  		status = -1;
***************
*** 371,377 ****
            snprintf(buf, BUFSIZ, "comterp(%s)", filename);
  	  err_print( stderr, buf );
            FILE* ofptr = handler() ? handler()->wrfptr() : stdout; 
! 	  fileptr_filebuf obuf(ofptr, ios_base::out);
  	  ostream ostr(&obuf);
  	  ostr.flush();
  	  status = -1;
--- 369,375 ----
            snprintf(buf, BUFSIZ, "comterp(%s)", filename);
  	  err_print( stderr, buf );
            FILE* ofptr = handler() ? handler()->wrfptr() : stdout; 
! 	  FILEBUF(obuf, ofptr, ios_base::out);
  	  ostream ostr(&obuf);
  	  ostr.flush();
  	  status = -1;
*** ./ivtools-1.2/src/ComTerp/ctrlfunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/ctrlfunc.c	2015-01-24 08:44:00.000000000 -0800
***************
*** 22,27 ****
--- 22,28 ----
   * 
   */
  
+ #include <unistd.h>
  #include <fstream.h>
  #include <iostream>
  #include <ComTerp/comhandler.h>
***************
*** 41,52 ****
  
  #define TITLE "CtrlFunc"
  
- #if __GNUC__>=3
  static char newline;
! #if __GNUC__>3||__GNUC_MINOR_>1
  #include <ext/stdio_filebuf.h>
  #endif
- #endif
  
  using std::cerr;
  
--- 42,51 ----
  
  #define TITLE "CtrlFunc"
  
  static char newline;
! #ifndef __APPLE__
  #include <ext/stdio_filebuf.h>
  #endif
  
  using std::cerr;
  
***************
*** 191,202 ****
  
  #ifdef HAVE_ACE
  
- #if __GNUC__==3&&__GNUC_MINOR__<1
-   fprintf(stderr, "Please upgrade to gcc-3.1 or greater\n");
-   push_stack(ComValue::nullval());
-   return;
- #endif
- 
    ACE_SOCK_STREAM *socket = nil;
    ACE_SOCK_Connector *conn = nil;
    SocketObj* socketobj = nil;
--- 190,195 ----
***************
*** 226,256 ****
    } else
      return;
    
- #if 0
- #if __GNUC__<3
-   filebuf ofbuf;
-   ofbuf.attach(socket->get_handle());
- #elif __GNUC__<4 && !defined(__CYGWIN__)
-   fileptr_filebuf ofbuf((int)socket->get_handle(), ios_base::out,
- 			false, static_cast<size_t>(BUFSIZ));
- #else
-   fileptr_filebuf ofbuf((int)socket->get_handle(), ios_base::out,
- 			static_cast<size_t>(BUFSIZ));
- #endif
-   ostream out(&ofbuf);
-   out << cmdstr;
-   if (cmdstr[strlen(cmdstr)-1] != '\n') out << "\n";
-   out.flush();
- #else
- #if 0
-   int i=0;
-   do {
-     if(write(socket->get_handle(), cmdstr+i++, 1)!=1)
-       fprintf(stderr, "Unexpected error writing byte to socket\n");
-   } while ( cmdstr[i]!='\0');
-   if (cmdstr[i-1] != '\n')  
-     write(socket->get_handle(), "\n", 1);
- #else
    int cmdlen = strlen(cmdstr);
    int newline_flag = cmdstr[cmdlen-1]=='\n';
    if (!newline_flag) cmdstr[cmdlen]='\n';
--- 219,224 ----
***************
*** 258,273 ****
    if (nbytes != cmdlen+(newline_flag?0:1))
        fprintf(stderr, "write to socket failed\n");
    if (!newline_flag) cmdstr[cmdlen]='\0';
- #endif
- #endif
    if (nowaitv.is_false()) {
- #if __GNUC__<3
-     filebuf ifbuf;
-     ifbuf.attach(socket->get_handle());
-     istream in(&ifbuf);
-     char* buf;
-     in.gets(&buf);
- #else
      char buf[BUFSIZ];
      int i=0;
      do {
--- 226,232 ----
***************
*** 275,281 ****
      } while (i<BUFSIZ-1 && buf[i-1]!='\n');
      if (buf[i-1]=='\n') buf[i]=0;
      // fprintf(stderr, "buf read back from remote %s", buf);
- #endif
      ComValue retval(comterpserv()->run(buf, true));
      push_stack(retval);
    }
--- 234,239 ----
***************
*** 346,357 ****
  
  #ifdef HAVE_ACE
  
- #if __GNUC__==3&&__GNUC_MINOR__<1
-   fprintf(stderr, "Please upgrade to gcc-3.1 or greater\n");
-   push_stack(ComValue::nullval());
-   return;
- #endif
- 
    if (hostv.is_string() && portv.is_known()) {
  
      const char* hoststr = hostv.string_ptr();
--- 304,309 ----
*** ./ivtools-1.2/src/ComTerp/debugfunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/debugfunc.c	2015-01-25 17:09:51.000000000 -0800
***************
*** 22,34 ****
   * 
   */
  
- #if __GNUC__==2 && __GNUC_MINOR__<=7
- #else
  #include <vector>
- #endif
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  #include <ComTerp/comhandler.h>
  
--- 22,29 ----
***************
*** 82,91 ****
    comterp()->npause()++;
  
    comterp()->push_servstate();
!   fileptr_filebuf fbufin(comterp() && comterp()->handler() && comterp()->handler()->rdfptr() 
  		 ? comterp()->handler()->rdfptr() : stdin, ios_base::in);
    istream in(&fbufin);
!   fileptr_filebuf fbufout(comterp()->handler() && comterp()->handler()->wrfptr()
  		  ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbufout);
  
--- 77,86 ----
    comterp()->npause()++;
  
    comterp()->push_servstate();
!   FILEBUF(fbufin, comterp() && comterp()->handler() && comterp()->handler()->rdfptr() 
  		 ? comterp()->handler()->rdfptr() : stdin, ios_base::in);
    istream in(&fbufin);
!   FILEBUF(fbufout, comterp()->handler() && comterp()->handler()->wrfptr()
  		  ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbufout);
  
*** ./ivtools-1.2/src/ComTerp/helpfunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/helpfunc.c	2015-01-25 17:10:28.000000000 -0800
***************
*** 36,44 ****
  
  #include <iostream.h>
  #include <strstream>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  #include <streambuf>
  using std::streambuf;
  
--- 36,42 ----
***************
*** 96,102 ****
  	    comfuncs[i] = (ComFunc*)((ComValue*)vptr)->obj_val();
  	} else
  	  comfuncs[i] = nil;
- 	command_ids[i] = val.string_val();
  	str_flags[i] = true;
        } else {
  	comfuncs[i] = nil;
--- 94,99 ----
***************
*** 163,186 ****
    reset_stack();
  
    std::strstreambuf sbuf;
! #if __GNUC__<3
!   filebuf fbuf;
!   if (comterp()->handler() && HELPOUT) {
!     int fd = Math::max(1, comterp()->handler()->get_handle());
!     fbuf.attach(fd);
!   } 
!   ostream outs( (comterp()->handler() && HELPOUT) ? ((streambuf*)&fbuf) : (streambuf*)&sbuf );
!   ostream *out = &outs;
! #else
!   fileptr_filebuf fbuf((comterp()->handler() && HELPOUT) && comterp()->handler()->wrfptr()
  	       ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
- #if 1
    ostream outs((comterp()->handler() && HELPOUT) ? (streambuf*)&fbuf : (streambuf*)&sbuf);
- #else
-   ostream outs((streambuf*)&fbuf);
- #endif
    ostream *out = &outs;
! #endif
  
    if (noargs) {
  
--- 160,170 ----
    reset_stack();
  
    std::strstreambuf sbuf;
!   FILEBUF(fbuf, comterp()->handler() && HELPOUT && comterp()->handler()->wrfptr()
  	       ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
    ostream outs((comterp()->handler() && HELPOUT) ? (streambuf*)&fbuf : (streambuf*)&sbuf);
    ostream *out = &outs;
! 
  
    if (noargs) {
  
***************
*** 199,219 ****
  	  if (first) 
  	    first = false;
  	  else
- #if 0
- 	    out->put('\n');
- #else
  	    *out << '\n';
- #endif
- #if __GNUC__<3
- 	  out->form(comfuncs[i]->docstring2(), symbol_pntr(command_ids[i]));
- #else
  	  {
  	    char buffer[BUFSIZ];
  	    snprintf(buffer, BUFSIZ, 
  		     comfuncs[i]->docstring2(), symbol_pntr(command_ids[i]));
  	    *out << buffer;
  	  }
- #endif
  	  printed = true;
  	}
        }
--- 183,195 ----
***************
*** 234,249 ****
  		  first = false;
  		else
  		  out->put('\n');
- #if __GNUC__<3
- 		out->form(comfunc->docstring2(), symbol_pntr(value->command_symid()));
- #else
  		{
  		  char buffer[BUFSIZ];
  		  snprintf(buffer, BUFSIZ, 
  			   comfunc->docstring2(), symbol_pntr(value->command_symid()));
  		  *out << buffer;
  		}
- #endif
  	      } else 
  		out_form((*out), "unknown operator: %s\n", symbol_pntr(command_ids[i]));
  
--- 210,221 ----
***************
*** 266,273 ****
  
    if (!comterp()->handler() || !HELPOUT) {
      *out << '\0';
!     int help_str_symid = symbol_add(sbuf.str());
!     ComValue retval(sbuf.str()); 
      push_stack(retval);
    } else
      out->flush();
--- 238,245 ----
  
    if (!comterp()->handler() || !HELPOUT) {
      *out << '\0';
!     // int help_str_symid = symbol_add(sbuf.str());
!     ComValue retval(sbuf.str());
      push_stack(retval);
    } else
      out->flush();
*** ./ivtools-1.2/src/ComTerp/iofunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/iofunc.c	2015-01-25 17:13:10.000000000 -0800
***************
*** 36,41 ****
--- 36,42 ----
  #include <fstream.h>
  #endif
  #include <streambuf>
+ #include <unistd.h>
  
  #define TITLE "IoFunc"
  
***************
*** 116,157 ****
    const char* fstr = formatstr.is_string() ? formatstr.string_ptr() : "nil";
    ComValue::comterp(comterp());
  
- #if __GNUC__<3
-   streambuf* strmbuf = nil;
-   if (stringflag.is_false() && strflag.is_false() &&
-       symbolflag.is_false() && symflag.is_false()) {
-     filebuf * fbuf = new filebuf();
-     strmbuf = fbuf;
-     if (comterp()->handler()) {
-       int fd = Math::max(1, comterp()->handler()->get_handle());
-       fbuf->attach(fd);
-     } else
-       fbuf->attach(fileno(errflag.is_false() ? stdout : stderr));
-   } else {
-     strmbuf = new std::strstreambuf();
-   }
- #else
    streambuf* strmbuf = nil;
    if (stringflag.is_false() && strflag.is_false() &&
        symbolflag.is_false() && symflag.is_false()) {
      fileptr_filebuf * fbuf = nil;
      if (comterp()->handler() && fileobjv.is_unknown() && errflag.is_false() && outflag.is_false()) {
!       fbuf = new fileptr_filebuf(comterp()->handler() && comterp()->handler()->wrfptr() 
! 			 ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
      } else if (fileobjv.is_known()) {
        FileObj *fileobj = (FileObj*)fileobjv.geta(FileObj::class_symid());
!       if (fileobj) 
!         fbuf = new fileptr_filebuf(fileobj->fptr(), ios_base::out);
!       else {
          PipeObj *pipeobj = (PipeObj*)fileobjv.geta(PipeObj::class_symid());
!         fbuf = new fileptr_filebuf(pipeobj ? pipeobj->wrfptr() : stdout, ios_base::out);
        }
!     } else 
!       fbuf = new fileptr_filebuf(errflag.is_false() ? stdout : stderr, ios_base::out);
      strmbuf = fbuf;
    } else
      strmbuf = new std::strstreambuf();
- #endif
    ostream out(strmbuf);
  
    int narg = nargsfixed();
--- 117,143 ----
    const char* fstr = formatstr.is_string() ? formatstr.string_ptr() : "nil";
    ComValue::comterp(comterp());
  
    streambuf* strmbuf = nil;
    if (stringflag.is_false() && strflag.is_false() &&
        symbolflag.is_false() && symflag.is_false()) {
      fileptr_filebuf * fbuf = nil;
      if (comterp()->handler() && fileobjv.is_unknown() && errflag.is_false() && outflag.is_false()) {
!       FILEBUFP(fbuf, comterp()->handler() && comterp()->handler()->wrfptr() 
! 	       ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
      } else if (fileobjv.is_known()) {
        FileObj *fileobj = (FileObj*)fileobjv.geta(FileObj::class_symid());
!       if (fileobj) {
!         FILEBUFP(fbuf, fileobj->fptr(), ios_base::out);
!       } else {
          PipeObj *pipeobj = (PipeObj*)fileobjv.geta(PipeObj::class_symid());
!         FILEBUFP(fbuf, pipeobj ? pipeobj->wrfptr() : stdout, ios_base::out);
        }
!     } else {
!       FILEBUFP(fbuf, errflag.is_false() ? stdout : stderr, ios_base::out);
!     }
      strmbuf = fbuf;
    } else
      strmbuf = new std::strstreambuf();
    ostream out(strmbuf);
  
    int narg = nargsfixed();
***************
*** 373,378 ****
--- 359,365 ----
      PipeObj* pipeobj = new PipeObj(filenamev.string_ptr());
      ComValue retval(PipeObj::class_symid(), (void*)pipeobj);
      push_stack(retval);
+ #ifdef HAVE_ACE
      if (Component::use_unidraw()) {
        ComterpHandler* pipe_handler = new ComterpHandler(comterpserv());
        if (ComterpHandler::reactor_singleton()->register_handler(pipeobj->rdfd(), pipe_handler, 
***************
*** 382,387 ****
--- 369,375 ----
        }
        pipe_handler->log_only(1);
      }
+ #endif
    } else {
      FileObj* fileobj = new FileObj(filenamev.string_ptr(), modev.is_string() ? modev.string_ptr() : "r", pipeflagv.is_true());
      if (fileobj->fptr())  {
*** ./ivtools-1.2/src/ComTerp/parser.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/parser.c	2015-01-24 08:46:20.000000000 -0800
***************
*** 30,38 ****
  
  #define TITLE "Parser"
  
- #if __GNUC__>=3
  static char newline;
- #endif
  
  /*****************************************************************************/
  
--- 30,36 ----
***************
*** 152,165 ****
  
  char* Parser::istream_fgets(char* s, int n, void* instreamp) {
    istream& in  = *(istream*)instreamp;
- #if __GNUC__<3
-   char *instr;
-   in.gets(&instr);
- #else
    char instr[BUFSIZ];
    in.get(instr, BUFSIZ);  // needs to be generalized with <vector.h>
    in.get(newline);
- #endif
    if (in.good()) {
      int i = 0;
      for (; i<n-2; i++) {
--- 150,158 ----
*** ./ivtools-1.2/src/ComTerp/postfunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComTerp/postfunc.c	2015-01-25 17:12:30.000000000 -0800
***************
*** 52,59 ****
  
  void PostFixFunc::execute() {
    // print everything on the stack for this function
!   fileptr_filebuf fbuf(comterp()->handler() && comterp()->handler()->wrfptr()
! 	       ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbuf);
   
    boolean oldbrief = comterp()->brief();
--- 52,59 ----
  
  void PostFixFunc::execute() {
    // print everything on the stack for this function
!   FILEBUF(fbuf, comterp()->handler() && comterp()->handler()->wrfptr()
! 	  ? comterp()->handler()->wrfptr() : stdout, ios_base::out);
    ostream out(&fbuf);
   
    boolean oldbrief = comterp()->brief();
*** ./ivtools-1.2/src/comterp_/main.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/comterp_/main.c	2015-01-25 17:17:36.000000000 -0800
***************
*** 109,117 ****
  	}
  
          // Perform logging service until COMTERP_QUIT_HANDLER receives SIGINT.
!         while (COMTERP_QUIT_HANDLER::instance ()->is_set () == 0)
              ComterpHandler::reactor_singleton()->handle_events ();
!     
          return 0;
      }
      if (client_flag || telcat_flag) {
--- 109,117 ----
  	}
  
          // Perform logging service until COMTERP_QUIT_HANDLER receives SIGINT.
!         while (COMTERP_QUIT_HANDLER::instance ()->is_set () == 0) {
              ComterpHandler::reactor_singleton()->handle_events ();
! 	}
          return 0;
      }
      if (client_flag || telcat_flag) {
***************
*** 134,155 ****
  
      if (!telcat_flag) {
        
- #if __GNUC__<3
-       filebuf obuf;
-       obuf.attach(server.get_handle());
- #else
        FILE* ofptr = nil;
!       fileptr_filebuf obuf(ofptr = fdopen(server.get_handle(), "w"), ios_base::out);
! #endif
        ostream out(&obuf);
        
- #if __GNUC__<3
-       filebuf ibuf;
-       ibuf.attach(server.get_handle());
- #else
        FILE* ifptr = nil;
!       fileptr_filebuf ibuf(ifptr = fdopen(server.get_handle(), "r"), ios_base::in);
! #endif
        
        istream in(&ibuf);
        
--- 134,145 ----
  
      if (!telcat_flag) {
        
        FILE* ofptr = nil;
!       FILEBUF(obuf, ofptr = fdopen(server.get_handle(), "w"), ios_base::out);
        ostream out(&obuf);
        
        FILE* ifptr = nil;
!       FILEBUF(ibuf, ifptr = fdopen(server.get_handle(), "r"), ios_base::in);
        
        istream in(&ibuf);
        
***************
*** 158,176 ****
  	if (feof(inptr)) break;
  	out << buffer;
  	out.flush();
- #if __GNUC__<3
- 	char* inbuf;
- 	char ch;
- 	ch = in.get();
- 	if (ch == '>')
- 	  ch = in.get(); // ' '
- 	else {
- 	  in.unget();
- 	  in.gets(&inbuf);
- 	  if (client_flag) 
- 	    cout << inbuf << "\n";
- 	}
- #else
  	char inbuf[BUFSIZ];
  	char ch;
  	ch = in.get();
--- 148,153 ----
***************
*** 183,192 ****
  	  if (client_flag) 
  	    cout << inbuf << "\n";
  	}
- #endif
        }
  
! #if __GNUC__>=3
        if (ofptr) fclose(ofptr);
        if (ifptr) fclose(ifptr);
  #endif
--- 160,168 ----
  	  if (client_flag) 
  	    cout << inbuf << "\n";
  	}
        }
  
! #ifndef __APPLE__
        if (ofptr) fclose(ofptr);
        if (ifptr) fclose(ifptr);
  #endif
***************
*** 194,215 ****
      } else if (inptr) {
  
  
! #if __GNUC__<3
!       filebuf inbuf;
!       inbuf.attach(fileno(inptr));
! #else
!       fileptr_filebuf inbuf(inptr, ios_base::in);
! #endif
        istream in(&inbuf);
        
  
! #if __GNUC__<3
!       filebuf obuf;
!       obuf.attach(server.get_handle());
! #else
!       FILE* ofptr = nil;
!       fileptr_filebuf obuf(fdopen(server.get_handle(), "w"), ios_base::out);
! #endif
        ostream out(&obuf);
  
        char buffer[BUFSIZ*BUFSIZ];
--- 170,180 ----
      } else if (inptr) {
  
  
!       FILEBUF(inbuf, inptr, ios_base::in);
        istream in(&inbuf);
        
  
!       FILEBUF(obuf, fdopen(server.get_handle(), "w"), ios_base::out);
        ostream out(&obuf);
  
        char buffer[BUFSIZ*BUFSIZ];
***************
*** 219,225 ****
  	  out.write(buffer, in.gcount());
        }
        out.flush();
! #if __GNUC__>=3
        if (ofptr) fclose(ofptr);
  #endif
      } else 
--- 184,190 ----
  	  out.write(buffer, in.gcount());
        }
        out.flush();
! #ifndef __APPLE__
        if (ofptr) fclose(ofptr);
  #endif
      } else 
*** ./ivtools-1.2/src/ComUnidraw/unifunc.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComUnidraw/unifunc.c	2015-01-25 17:44:03.000000000 -0800
***************
*** 54,68 ****
  #include <Unidraw/Graphic/graphic.h>
  #include <InterViews/transformer.h>
  #include <InterViews/window.h>
  #include <ComTerp/comterpserv.h>
  #include <ComTerp/comvalue.h>
  #include <Attribute/attrlist.h>
  #include <stdio.h>
  #include <strstream>
  #include <unistd.h>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  #include <string.h>
  #include <iostream>
  
--- 54,67 ----
  #include <Unidraw/Graphic/graphic.h>
  #include <InterViews/transformer.h>
  #include <InterViews/window.h>
+ #include <ComTerp/comhandler.h>
  #include <ComTerp/comterpserv.h>
  #include <ComTerp/comvalue.h>
  #include <Attribute/attrlist.h>
  #include <stdio.h>
  #include <strstream>
  #include <unistd.h>
  #include <fstream.h>
  #include <string.h>
  #include <iostream>
  
***************
*** 409,456 ****
  #endif
  
  
- #if __GNUC__<3
-     filebuf fbuf;
-     if (file.is_type(ComValue::StringType))
-         fbuf.open(file.string_ptr(), "w");
- 
-     else if (sock.is_true()) {
- #ifdef HAVE_ACE
- 	ComTerpServ* terp = (ComTerpServ*)comterp();
- 	ComterpHandler* handler = (ComterpHandler*)terp->handler();
- 	if (handler) {
- 	  ACE_SOCK_Stream peer = handler->peer();
- 	  fbuf.attach(peer.get_handle());
- 	}
- 	else
- #endif
- 	  fbuf.attach(fileno(stdout));
-     }
- 
-     else {
- #ifdef HAVE_ACE
-         const char* hoststr = nil;
-         const char* portstr = nil;
-         hoststr = host.type()==ComValue::StringType ? host.string_ptr() : nil;
-         portstr = port.type()==ComValue::StringType ? port.string_ptr() : nil;
-         u_short portnum = portstr ? atoi(portstr) : port.ushort_val();
-     
-         if (portnum) {
-             socket = new ACE_SOCK_Stream;
-             ACE_SOCK_Connector conn;
-             ACE_INET_Addr addr (portnum, hoststr);
-     
-             if (conn.connect (*socket, addr) == -1)
-                 ACE_ERROR ((LM_ERROR, "%p\n", "open"));
-             fbuf.attach(socket->get_handle());
-         } else if (comterp()->handler() && comterp()->handler()->get_handle()>-1) {
-             fbuf.attach(comterp()->handler()->get_handle());
-         } else
- #endif
-             fbuf.attach(fileno(stdout));
-     }
- 
- #else
  
      filebuf* pfbuf;
      FILE* ofptr = nil;
--- 408,413 ----
***************
*** 467,477 ****
  	if (handler) {
  	  ACE_SOCK_Stream peer = handler->peer();
  	  ofptr = fdopen(peer.get_handle(), "r");
! 	  pfbuf = new fileptr_filebuf(ofptr, output);
  	}
  	else 
  #endif
! 	  pfbuf = new fileptr_filebuf(stdout, output);
      }
  
      else {
--- 424,434 ----
  	if (handler) {
  	  ACE_SOCK_Stream peer = handler->peer();
  	  ofptr = fdopen(peer.get_handle(), "r");
! 	  FILEBUFP(pfbuf, ofptr, output);
  	}
  	else 
  #endif
! 	  FILEBUFP(pfbuf, stdout, output);
      }
  
      else {
***************
*** 489,512 ****
      
              if (conn.connect (*socket, addr) == -1)
                  ACE_ERROR ((LM_ERROR, "%p\n", "open"));
!             pfbuf = new fileptr_filebuf(ofptr = fdopen(socket->get_handle(), "r"), output);
          } else if (comterp()->handler() && comterp()->handler()->get_handle()>-1) {
!             pfbuf = new fileptr_filebuf(comterp()->handler()->rdfptr(), output);
          } else
  #endif
!             pfbuf = new fileptr_filebuf(stdout, output);
      }
  
- #endif
      ostream* out;
      if (string.is_true()||str.is_true())
        out = new std::strstream();
      else
- #if __GNUC__<3      
-       out = new ostream(&fbuf);
- #else
        out = new ostream(pfbuf);
- #endif
  
      if (!compviewv.is_array()) {
  
--- 446,464 ----
      
              if (conn.connect (*socket, addr) == -1)
                  ACE_ERROR ((LM_ERROR, "%p\n", "open"));
!             FILEBUFP(pfbuf, ofptr = fdopen(socket->get_handle(), "r"), output);
          } else if (comterp()->handler() && comterp()->handler()->get_handle()>-1) {
! 	  FILEBUFP(pfbuf, comterp()->handler()->rdfptr(), output);
          } else
  #endif
! 	  FILEBUFP(pfbuf, stdout, output);
      }
  
      ostream* out;
      if (string.is_true()||str.is_true())
        out = new std::strstream();
      else
        out = new ostream(pfbuf);
  
      if (!compviewv.is_array()) {
  
***************
*** 568,576 ****
      }
      delete out;
  
- #if __GNUC__>=3
      delete pfbuf;
- #endif    
      
  #ifdef HAVE_ACE
      if (sock.is_false() && socket) {
--- 520,526 ----
*** ./ivtools-1.2/src/ComUtil/errsys.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComUtil/errsys.c	2015-01-22 12:06:29.000000000 -0800
***************
*** 212,225 ****
      }
  
      if (!fptr) {
! 	strcpy( fullpath, RELLIBALLDIR );
  	if (fullpath[strlen(fullpath)-1] != '/') strcat( fullpath, "/" );
  	strcat( fullpath, errfile );
  	fptr = fopen(fullpath, "r");
      }
      
      if (!fptr) {
! 	strcpy( fullpath, ABSLIBALLDIR );
  	if (fullpath[strlen(fullpath)-1] != '/') strcat( fullpath, "/" );
  	strcat( fullpath, errfile );
  	fptr = fopen(fullpath, "r");
--- 212,225 ----
      }
  
      if (!fptr) {
! 	strcpy( fullpath, "RELLIBALLDIR" );
  	if (fullpath[strlen(fullpath)-1] != '/') strcat( fullpath, "/" );
  	strcat( fullpath, errfile );
  	fptr = fopen(fullpath, "r");
      }
      
      if (!fptr) {
! 	strcpy( fullpath, "ABSLIBALLDIR" );
  	if (fullpath[strlen(fullpath)-1] != '/') strcat( fullpath, "/" );
  	strcat( fullpath, errfile );
  	fptr = fopen(fullpath, "r");
*** ./ivtools-1.2/src/ComUtil/Imakefile.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/ComUtil/Imakefile	2015-01-22 12:04:27.000000000 -0800
***************
*** 16,22 ****
  Obj(comerr)
  Obj(dmm)
  Obj(errfile)
! MakeObjectFromSrcFlags(errsys,-DABSLIBALLDIR=\"$(ABSLIBALLDIR)/\" -DRELLIBALLDIR=\"$(RELLIBALLDIR)/\")
  Obj(funcptrs)
  Obj(_lexscan)
  Obj(mblock)
--- 16,22 ----
  Obj(comerr)
  Obj(dmm)
  Obj(errfile)
! MakeObjectFromSrcFlags(errsys,-DABSLIBALLDIR=$(ABSLIBALLDIR)/ -DRELLIBALLDIR=$(RELLIBALLDIR)/)
  Obj(funcptrs)
  Obj(_lexscan)
  Obj(mblock)
*** ./ivtools-1.2/src/DrawServ/drawcatalog.c.dist	2015-01-27 13:46:29.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/drawcatalog.c	2015-01-27 11:45:50.000000000 -0800
***************
*** 37,45 ****
  #include <iostream.h>
  #include <stdio.h>
  #include <string.h>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  /*****************************************************************************/
  
--- 37,43 ----
***************
*** 60,87 ****
          _valid = true;
  
      } else {
- #if __GNUC__<3
-         filebuf fbuf;
- #else
          filebuf* pfbuf = nil;
- #endif
  	if (strcmp(name, "-") == 0) {
! #if __GNUC__<3
! 	    _valid = fbuf.attach(fileno(stdin)) != 0;
! #else
! 	    pfbuf = new fileptr_filebuf(stdin, input);
  	    _valid = 1;
- #endif
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
! #if __GNUC__<3
! 	    _valid = fptr ? fbuf.attach(fileno(fptr)) != 0 : false;
! #else
! 	    pfbuf = new fileptr_filebuf(fptr, input);
  	    _valid = fptr ? 1 : 0;
- #endif
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
--- 58,73 ----
          _valid = true;
  
      } else {
          filebuf* pfbuf = nil;
  	if (strcmp(name, "-") == 0) {
! 	    FILEBUFP(pfbuf, stdin, input);
  	    _valid = 1;
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
! 	    FILEBUFP(pfbuf, fptr, input);
  	    _valid = fptr ? 1 : 0;
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
***************
*** 90,100 ****
  	}
  	
          if (_valid) {
- #if __GNUC__<3
- 	    istream in(&fbuf);
- #else
  	    istream in(pfbuf);
- #endif
  	    const char* command = "drawserv";
  	    int len = strlen(command)+1;
  	    char buf[len];
--- 76,82 ----
***************
*** 116,124 ****
  		comp = nil;
  	    }
          }
- #if __GNUC__>=3
  	delete pfbuf;
- #endif
      }
      
      if (fptr) {
--- 98,104 ----
*** ./ivtools-1.2/src/DrawServ/drawfunc.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/drawfunc.c	2015-01-27 11:52:08.000000000 -0800
***************
*** 82,93 ****
    ComValue userv(stack_key(user_sym));
    reset_stack();
  
- #if __GNUC__==3&&__GNUC_MINOR__<1
-   fprintf(stderr, "Please upgrade to gcc-3.1 or greater\n");
-   push_stack(ComValue::nullval());
-   return;
- #endif
- 
    DrawLink* link = nil;
  
    /* creating a new link to remote drawserv */
--- 82,87 ----
***************
*** 97,115 ****
      if (statev.int_val()==DrawLink::one_way && 
  	((DrawServ*)unidraw)->cycletest
  	(sidv.uint_val(), hostv.string_ptr(), userv.string_ptr(), pidv.int_val())) {
! #if 1
! #if __GNUC__<4 && !defined(__CYGWIN__)
!       fileptr_filebuf obuf(comterp()->handler()->get_handle(), ios_base::out, false, static_cast<size_t>(BUFSIZ));
! #else
!       fileptr_filebuf obuf(comterp()->handler()->get_handle(), ios_base::out, static_cast<size_t>(BUFSIZ));
! #endif
        ostream out(&obuf);
        out << "ackback(cycle)\n";
        out.flush();
        comterp()->quit();
- #else
-       comterp()->handler()->destroy();
- #endif
        return;
      }
      
--- 91,101 ----
      if (statev.int_val()==DrawLink::one_way && 
  	((DrawServ*)unidraw)->cycletest
  	(sidv.uint_val(), hostv.string_ptr(), userv.string_ptr(), pidv.int_val())) {
!       FILEBUF(obuf, comterp()->handler()->wrfptr(), ios_base::out);
        ostream out(&obuf);
        out << "ackback(cycle)\n";
        out.flush();
        comterp()->quit();
        return;
      }
      
***************
*** 203,213 ****
  
    reset_stack();
  
- #if __GNUC__==3&&__GNUC_MINOR__<1
-   fprintf(stderr, "Please upgrade to gcc-3.1 or greater\n");
-   push_stack(ComValue::nullval());
-   return;
- #endif
    DrawServHandler* handler = comterp() ? (DrawServHandler*)comterp()->handler() : nil;
    DrawLink* link = handler ? (DrawLink*)handler->drawlink() : nil;
    
--- 189,194 ----
***************
*** 233,238 ****
--- 214,220 ----
  
  /*****************************************************************************/
  
+ #ifdef HAVE_ACE
  GraphicIdFunc::GraphicIdFunc(ComTerp* comterp, Editor* ed) : UnidrawFunc(comterp, ed) {
  }
  
***************
*** 292,297 ****
--- 274,280 ----
    }
  }
  
+ #endif /* defined(HAVE_ACE) */
  
  /*****************************************************************************/
  
*** ./ivtools-1.2/src/DrawServ/drawfunc.h.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/drawfunc.h	2015-01-24 10:59:14.000000000 -0800
***************
*** 47,52 ****
--- 47,53 ----
  	return "%s([sid osid :pid pid :user namestr :host hoststr :hostid hostid :remap] | :all) -- command to manage session id's"; }
  };
  
+ #ifdef HAVE_ACE
  //: command to send message between remote selections
  // grid(id selector :state selected :request newselector :grant oldselector) -- command to send message between remote selections
  class GraphicIdFunc : public UnidrawFunc {
***************
*** 66,71 ****
--- 67,73 ----
      virtual const char* docstring() { 
  	return "%s(id) -- command to change session (or graphic id) to use local session id"; }
  };
+ #endif /* defined(HAVE_ACE) */
  
  //: command to return point list associated with a graphic
  // ptlist=points(compview) -- return point list from compview graphic
*** ./ivtools-1.2/src/DrawServ/drawlink.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/drawlink.c	2015-01-27 11:53:36.000000000 -0800
***************
*** 99,109 ****
      if (ComterpHandler::reactor_singleton()->register_handler(ackhandler(), ACE_Event_Handler::READ_MASK|ACE_Event_Handler::TIMER_MASK)==-1)
        fprintf(stderr, "drawserv: error registering ackback handler (handle==%d)\n", _socket->get_handle());
  
! #if __GNUC__<4 && !defined(__CYGWIN__)
!     fileptr_filebuf obuf(_socket->get_handle(), ios_base::out, false, static_cast<size_t>(BUFSIZ));
! #else
!     fileptr_filebuf obuf(_socket->get_handle(), ios_base::out, static_cast<size_t>(BUFSIZ));
! #endif
      ostream out(&obuf);
      out << "drawlink(\"";
      char buffer[HOST_NAME_MAX];
--- 99,105 ----
      if (ComterpHandler::reactor_singleton()->register_handler(ackhandler(), ACE_Event_Handler::READ_MASK|ACE_Event_Handler::TIMER_MASK)==-1)
        fprintf(stderr, "drawserv: error registering ackback handler (handle==%d)\n", _socket->get_handle());
  
!     FILEBUF(obuf, fdopen(_socket->get_handle(), "w"), ios_base::out);
      ostream out(&obuf);
      out << "drawlink(\"";
      char buffer[HOST_NAME_MAX];
*** ./ivtools-1.2/src/DrawServ/drawserv.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/drawserv.c	2015-01-27 11:55:32.000000000 -0800
***************
*** 368,378 ****
      if (link && link != orglink && link->state()==DrawLink::two_way) {
        int fd = link->handle();
        if (fd>=0) {
! #if __GNUC__<4 && !defined(__CYGWIN__)
! 	fileptr_filebuf fbuf(fd, ios_base::out, false, static_cast<size_t>(BUFSIZ));
! #else
! 	fileptr_filebuf fbuf(fd, ios_base::out, static_cast<size_t>(BUFSIZ));
! #endif
  	ostream out(&fbuf);
  	out << cmdstring;
  	out << "\n";
--- 368,374 ----
      if (link && link != orglink && link->state()==DrawLink::two_way) {
        int fd = link->handle();
        if (fd>=0) {
! 	FILEBUF(fbuf, fdopen(fd, "w"), ios_base::out);
  	ostream out(&fbuf);
  	out << cmdstring;
  	out << "\n";
***************
*** 390,400 ****
    if (link) {
      int fd = link->handle();
      if (fd>=0) {
! #if __GNUC__<4 && !defined(__CYGWIN__)
!       fileptr_filebuf fbuf(fd, ios_base::out, false, static_cast<size_t>(BUFSIZ));
! #else
!       fileptr_filebuf fbuf(fd, ios_base::out, static_cast<size_t>(BUFSIZ));
! #endif
        ostream out(&fbuf);
        out << cmdstring;
        out << "\n";
--- 386,392 ----
    if (link) {
      int fd = link->handle();
      if (fd>=0) {
!       FILEBUF(fbuf, fdopen(fd, "w"), ios_base::out);
        ostream out(&fbuf);
        out << cmdstring;
        out << "\n";
*** ./ivtools-1.2/src/DrawServ/Imakefile.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/DrawServ/Imakefile	2015-01-24 11:01:02.000000000 -0800
***************
*** 32,37 ****
--- 32,39 ----
  Obj26A(drawlink)
  Obj26(drawlinkcomp)
  Obj26(drawlinklist)
+ #else
+ Obj26(drawfunc)
  #endif
  Obj26(drawserv)
  Obj26A(drawserv-handler)
*** ./ivtools-1.2/src/drawserv_/main.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/drawserv_/main.c	2015-01-27 11:56:03.000000000 -0800
***************
*** 283,291 ****
--- 283,293 ----
      // Register COMTERP_QUIT_HANDLER to receive SIGINT commands.  When received,
      // COMTERP_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
+ #if 0
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, COMTERP_QUIT_HANDLER::instance ()) == -1)
          cerr << "drawserv:  unable to register quit handler with ACE reactor\n";
+ #endif
  
  #endif
  
*** ./ivtools-1.2/src/drawtool/main.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/drawtool/main.c	2015-01-27 13:45:37.000000000 -0800
***************
*** 263,272 ****
      // Register IMPORT_QUIT_HANDLER to receive SIGINT commands.  When received,
      // IMPORT_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, IMPORT_QUIT_HANDLER::instance ()) == -1)
          cerr << "drawtool:  unable to register quit handler with ACE reactor\n";
! 
  #endif
  
      if (argc > 2) {
--- 263,273 ----
      // Register IMPORT_QUIT_HANDLER to receive SIGINT commands.  When received,
      // IMPORT_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
+ #if 0
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, IMPORT_QUIT_HANDLER::instance ()) == -1)
          cerr << "drawtool:  unable to register quit handler with ACE reactor\n";
! #endif
  #endif
  
      if (argc > 2) {
*** ./ivtools-1.2/src/flipbook/main.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/flipbook/main.c	2015-01-25 18:30:19.000000000 -0800
***************
*** 284,292 ****
--- 284,294 ----
      // Register IMPORT_QUIT_HANDLER to receive SIGINT commands.  When received,
      // IMPORT_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
+ #if 0
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, IMPORT_QUIT_HANDLER::instance ()) == -1)
          cerr << "flipbook:  unable to register quit handler with ACE reactor\n";
+ #endif
  
  #endif
      if (argc > 2) {
*** ./ivtools-1.2/src/FrameUnidraw/framecatalog.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/FrameUnidraw/framecatalog.c	2015-01-27 11:37:50.000000000 -0800
***************
*** 56,83 ****
          _valid = true;
  
      } else {
- #if __GNUC__<3
-         filebuf fbuf;
- #else
          filebuf* pfbuf = nil;
- #endif
  	if (strcmp(name, "-") == 0) {
! #if __GNUC__<3
! 	    _valid = fbuf.attach(fileno(stdin)) != 0;
! #else
! 	    pfbuf = new fileptr_filebuf(stdin, input);
  	    _valid = 1;
- #endif
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
! #if __GNUC__<3
! 	    _valid = fptr ? fbuf.attach(fileno(fptr)) != 0 : false;
! #else
! 	    pfbuf = fptr ? new fileptr_filebuf(fptr, input) : nil;
  	    _valid = fptr ? 1 : 0;
- #endif
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
--- 56,73 ----
          _valid = true;
  
      } else {
          filebuf* pfbuf = nil;
  	if (strcmp(name, "-") == 0) {
! 	    FILEBUFP(pfbuf, stdin, input);
  	    _valid = 1;
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
!             if (fptr) {
!  	        FILEBUFP(pfbuf, fptr, input);
! 	    }
  	    _valid = fptr ? 1 : 0;
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
***************
*** 86,96 ****
  	}
  
          if (_valid) {
- #if __GNUC__<3
- 	    istream in(&fbuf);
- #else
  	    istream in(pfbuf);
- #endif
  
  	    char ch;
  	    while (isspace(ch = in.get())); in.putback(ch);
--- 76,82 ----
***************
*** 115,123 ****
  	    }
          }
  
- #if __GNUC__>=3
  	delete pfbuf;
- #endif
      }
  
      if (fptr) {
--- 101,107 ----
*** ./ivtools-1.2/src/graphdraw/main.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/graphdraw/main.c	2015-01-27 11:44:11.000000000 -0800
***************
*** 270,279 ****
      // Register IMPORT_QUIT_HANDLER to receive SIGINT commands.  When received,
      // IMPORT_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, IMPORT_QUIT_HANDLER::instance ()) == -1)
          cerr << "graphdraw:  unable to register quit handler with ACE reactor\n";
! 
  #endif
  
      const char* initial_file = (argc == 2) ? argv[1] : nil;
--- 270,280 ----
      // Register IMPORT_QUIT_HANDLER to receive SIGINT commands.  When received,
      // IMPORT_QUIT_HANDLER becomes "set" and thus, the event loop below will
      // exit.
+ #if 0
      if (ComterpHandler::reactor_singleton()->register_handler 
  	     (SIGINT, IMPORT_QUIT_HANDLER::instance ()) == -1)
          cerr << "graphdraw:  unable to register quit handler with ACE reactor\n";
! #endif
  #endif
  
      const char* initial_file = (argc == 2) ? argv[1] : nil;
*** ./ivtools-1.2/src/GraphUnidraw/graphcatalog.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/GraphUnidraw/graphcatalog.c	2015-01-25 18:16:17.000000000 -0800
***************
*** 52,60 ****
  #include <stdio.h>
  #include <stream.h>
  #include <string.h>
- #if __GNUC__>=3
  #include <fstream.h>
- #endif
  
  /*****************************************************************************/
  
--- 52,58 ----
***************
*** 75,102 ****
          _valid = true;
  
      } else {
- #if __GNUC__<3
-         filebuf fbuf;
- #else
  	filebuf* pfbuf = nil;
- #endif
  	if (strcmp(name, "-") == 0) {
! #if __GNUC__<3
! 	    _valid = fbuf.attach(fileno(stdin)) != 0;
! #else
! 	    pfbuf = new fileptr_filebuf(stdin, input);
  	    _valid = 1;
- #endif
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
! #if __GNUC__<3
! 	    _valid = fptr ? fbuf.attach(fileno(fptr)) != 0 : false;
! #else
! 	    pfbuf = new fileptr_filebuf(fptr, input);
  	    _valid = fptr ? 1 : 0;
- #endif
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
--- 73,88 ----
          _valid = true;
  
      } else {
  	filebuf* pfbuf = nil;
  	if (strcmp(name, "-") == 0) {
! 	    FILEBUFP(pfbuf, stdin, input);
  	    _valid = 1;
  	    name = nil;
  	} else {
  	    fptr = fopen(name, "r");
  	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
! 	    FILEBUFP(pfbuf, fptr, input);
  	    _valid = fptr ? 1 : 0;
  	    if (compressed) {
  		int namelen = strlen(name);
  		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
***************
*** 105,115 ****
  	}
  
          if (_valid) {
- #if __GNUC__<3
- 	    istream in(&fbuf);
- #else
  	    istream in(pfbuf);
- #endif
  
  	    char ch;
  	    while (isspace(ch = in.get())); in.putback(ch);
--- 91,97 ----
***************
*** 131,139 ****
  		comp = nil;
  	    }
          }
- #if __GNUC__>=3
  	delete pfbuf;
- #endif
      }
  
      if (fptr) {
--- 113,119 ----
*** ./ivtools-1.2/src/include/ivstd/fstream.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/include/ivstd/fstream	2015-01-25 16:33:09.000000000 -0800
***************
*** 0 ****
--- 1,1571 ----
+ #ifndef __APPLE__
+ #include_next <fstream>
+ #else
+ // -*- C++ -*-
+ //===------------------------- fstream ------------------------------------===//
+ //
+ //                     The LLVM Compiler Infrastructure
+ //
+ // This file is dual licensed under the MIT and the University of Illinois Open
+ // Source Licenses. See LICENSE.TXT for details.
+ //
+ //===----------------------------------------------------------------------===//
+ 
+ #ifndef _LIBCPP_FSTREAM
+ #define _LIBCPP_FSTREAM
+ 
+ /*
+     fstream synopsis
+ 
+ template <class charT, class traits = char_traits<charT> >
+ class basic_filebuf
+     : public basic_streambuf<charT, traits>
+ {
+ public:
+     typedef charT                          char_type;
+     typedef traits                         traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     // 27.9.1.2 Constructors/destructor:
+     basic_filebuf();
+     basic_filebuf(basic_filebuf&& rhs);
+     virtual ~basic_filebuf();
+ 
+     // 27.9.1.3 Assign/swap:
+     basic_filebuf& operator=(basic_filebuf&& rhs);
+     void swap(basic_filebuf& rhs);
+ 
+     // 27.9.1.4 Members:
+     bool is_open() const;
+     basic_filebuf* open(const char* s, ios_base::openmode mode);
+     basic_filebuf* open(const string& s, ios_base::openmode mode);
+     basic_filebuf* open(FILE* fp, ios_base::openmode mode);
+     basic_filebuf* close();
+ 
+ protected:
+     // 27.9.1.5 Overridden virtual functions:
+     virtual streamsize showmanyc();
+     virtual int_type underflow();
+     virtual int_type uflow();
+     virtual int_type pbackfail(int_type c = traits_type::eof());
+     virtual int_type overflow (int_type c = traits_type::eof());
+     virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);
+     virtual pos_type seekoff(off_type off, ios_base::seekdir way,
+                              ios_base::openmode which = ios_base::in | ios_base::out);
+     virtual pos_type seekpos(pos_type sp,
+                              ios_base::openmode which = ios_base::in | ios_base::out);
+     virtual int sync();
+     virtual void imbue(const locale& loc);
+ };
+ 
+ template <class charT, class traits>
+   void
+   swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);
+ 
+ typedef basic_filebuf<char>    filebuf;
+ typedef basic_filebuf<wchar_t> wfilebuf;
+ 
+ template <class charT, class traits = char_traits<charT> >
+ class basic_ifstream
+     : public basic_istream<charT,traits>
+ {
+ public:
+     typedef charT                          char_type;
+     typedef traits                         traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_ifstream();
+     explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);
+     explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);
+     basic_ifstream(basic_ifstream&& rhs);
+ 
+     basic_ifstream& operator=(basic_ifstream&& rhs);
+     void swap(basic_ifstream& rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* s, ios_base::openmode mode = ios_base::in);
+     void open(const string& s, ios_base::openmode mode = ios_base::in);
+     void open(FILE* fp, ios_base::openmode mode = ios_base::in);
+     void close();
+ };
+ 
+ template <class charT, class traits>
+   void
+   swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);
+ 
+ typedef basic_ifstream<char>    ifstream;
+ typedef basic_ifstream<wchar_t> wifstream;
+ 
+ template <class charT, class traits = char_traits<charT> >
+ class basic_ofstream
+     : public basic_ostream<charT,traits>
+ {
+ public:
+     typedef charT                          char_type;
+     typedef traits                         traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_ofstream();
+     explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);
+     explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);
+     basic_ofstream(basic_ofstream&& rhs);
+ 
+     basic_ofstream& operator=(basic_ofstream&& rhs);
+     void swap(basic_ofstream& rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* s, ios_base::openmode mode = ios_base::out);
+     void open(const string& s, ios_base::openmode mode = ios_base::out);
+     void open(FILE* fp, ios_base::openmode mode = ios_base::out);
+     void close();
+ };
+ 
+ template <class charT, class traits>
+   void
+   swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);
+ 
+ typedef basic_ofstream<char>    ofstream;
+ typedef basic_ofstream<wchar_t> wofstream;
+ 
+ template <class charT, class traits=char_traits<charT> >
+ class basic_fstream
+     : public basic_iostream<charT,traits>
+ {
+ public:
+     typedef charT                          char_type;
+     typedef traits                         traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_fstream();
+     explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);
+     explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);
+     explicit basic_fstream(FILE* fp, ios_base::openmode mode = ios_base::in|ios_base::out);
+     basic_fstream(basic_fstream&& rhs);
+ 
+     basic_fstream& operator=(basic_fstream&& rhs);
+     void swap(basic_fstream& rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);
+     void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);
+     void open(FILE* fp, ios_base::openmode mode = ios_base::in|ios_base::out);
+     void close();
+ };
+ 
+ template <class charT, class traits>
+   void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);
+ 
+ typedef basic_fstream<char>    fstream;
+ typedef basic_fstream<wchar_t> wfstream;
+ 
+ }  // std
+ 
+ */
+ 
+ #include <__config>
+ #include <ostream>
+ #include <istream>
+ #include <__locale>
+ #include <cstdio>
+ 
+ #include <__undef_min_max>
+ 
+ #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+ #pragma GCC system_header
+ #endif
+ 
+ _LIBCPP_BEGIN_NAMESPACE_STD
+ 
+ template <class _CharT, class _Traits>
+ class _LIBCPP_TYPE_VIS_ONLY basic_filebuf
+     : public basic_streambuf<_CharT, _Traits>
+ {
+ public:
+     typedef _CharT                           char_type;
+     typedef _Traits                          traits_type;
+     typedef typename traits_type::int_type   int_type;
+     typedef typename traits_type::pos_type   pos_type;
+     typedef typename traits_type::off_type   off_type;
+     typedef typename traits_type::state_type state_type;
+ 
+     // 27.9.1.2 Constructors/destructor:
+     basic_filebuf();
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_filebuf(basic_filebuf&& __rhs);
+ #endif
+     virtual ~basic_filebuf();
+ 
+     // 27.9.1.3 Assign/swap:
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_filebuf& operator=(basic_filebuf&& __rhs);
+ #endif
+     void swap(basic_filebuf& __rhs);
+ 
+     // 27.9.1.4 Members:
+     bool is_open() const;
+     basic_filebuf* open(const char* __s, ios_base::openmode __mode);
+     basic_filebuf* open(const string& __s, ios_base::openmode __mode);
+     basic_filebuf* open(FILE* fd, ios_base::openmode __mode);
+     basic_filebuf* close();
+ 
+ protected:
+     // 27.9.1.5 Overridden virtual functions:
+     virtual int_type underflow();
+     virtual int_type pbackfail(int_type __c = traits_type::eof());
+     virtual int_type overflow (int_type __c = traits_type::eof());
+     virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);
+     virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
+                              ios_base::openmode __wch = ios_base::in | ios_base::out);
+     virtual pos_type seekpos(pos_type __sp,
+                              ios_base::openmode __wch = ios_base::in | ios_base::out);
+     virtual int sync();
+     virtual void imbue(const locale& __loc);
+ 
+ private:
+     int __fpflag;
+     char*       __extbuf_;
+     const char* __extbufnext_;
+     const char* __extbufend_;
+     char __extbuf_min_[8];
+     size_t __ebs_;
+     char_type* __intbuf_;
+     size_t __ibs_;
+     FILE* __file_;
+     const codecvt<char_type, char, state_type>* __cv_;
+     state_type __st_;
+     state_type __st_last_;
+     ios_base::openmode __om_;
+     ios_base::openmode __cm_;
+     bool __owns_eb_;
+     bool __owns_ib_;
+     bool __always_noconv_;
+ 
+     bool __read_mode();
+     void __write_mode();
+ };
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>::basic_filebuf()
+     : __fpflag(0),
+       __extbuf_(0),
+       __extbufnext_(0),
+       __extbufend_(0),
+       __ebs_(0),
+       __intbuf_(0),
+       __ibs_(0),
+       __file_(0),
+       __cv_(nullptr),
+       __st_(),
+       __st_last_(),
+       __om_(0),
+       __cm_(0),
+       __owns_eb_(false),
+       __owns_ib_(false),
+       __always_noconv_(false)
+ {
+     if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))
+     {
+         __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());
+         __always_noconv_ = __cv_->always_noconv();
+     }
+     setbuf(0, 4096);
+ }
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)
+     : basic_streambuf<_CharT, _Traits>(__rhs)
+ {
+     if (__rhs.__extbuf_ == __rhs.__extbuf_min_)
+     {
+         __extbuf_ = __extbuf_min_;
+         __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);
+         __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);
+     }
+     else
+     {
+         __extbuf_ = __rhs.__extbuf_;
+         __extbufnext_ = __rhs.__extbufnext_;
+         __extbufend_ = __rhs.__extbufend_;
+     }
+     __ebs_ = __rhs.__ebs_;
+     __intbuf_ = __rhs.__intbuf_;
+     __ibs_ = __rhs.__ibs_;
+     __file_ = __rhs.__file_;
+     __cv_ = __rhs.__cv_;
+     __st_ = __rhs.__st_;
+     __st_last_ = __rhs.__st_last_;
+     __om_ = __rhs.__om_;
+     __cm_ = __rhs.__cm_;
+     __owns_eb_ = __rhs.__owns_eb_;
+     __owns_ib_ = __rhs.__owns_ib_;
+     __always_noconv_ = __rhs.__always_noconv_;
+     if (__rhs.pbase())
+     {
+         if (__rhs.pbase() == __rhs.__intbuf_)
+             this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));
+         else
+             this->setp((char_type*)__extbuf_,
+                        (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));
+         this->pbump(__rhs. pptr() - __rhs.pbase());
+     }
+     else if (__rhs.eback())
+     {
+         if (__rhs.eback() == __rhs.__intbuf_)
+             this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),
+                                   __intbuf_ + (__rhs.egptr() - __rhs.eback()));
+         else
+             this->setg((char_type*)__extbuf_,
+                        (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),
+                        (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));
+     }
+     __rhs.__extbuf_ = 0;
+     __rhs.__extbufnext_ = 0;
+     __rhs.__extbufend_ = 0;
+     __rhs.__ebs_ = 0;
+     __rhs.__intbuf_ = 0;
+     __rhs.__ibs_ = 0;
+     __rhs.__file_ = 0;
+     __rhs.__st_ = state_type();
+     __rhs.__st_last_ = state_type();
+     __rhs.__om_ = 0;
+     __rhs.__cm_ = 0;
+     __rhs.__owns_eb_ = false;
+     __rhs.__owns_ib_ = false;
+     __rhs.setg(0, 0, 0);
+     __rhs.setp(0, 0);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_filebuf<_CharT, _Traits>&
+ basic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)
+ {
+     close();
+     swap(__rhs);
+     return *this;
+ }
+ 
+ #endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>::~basic_filebuf()
+ {
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+     try
+     {
+ #endif  // _LIBCPP_NO_EXCEPTIONS
+         close();
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+     }
+     catch (...)
+     {
+     }
+ #endif  // _LIBCPP_NO_EXCEPTIONS
+     if (__owns_eb_)
+         delete [] __extbuf_;
+     if (__owns_ib_)
+         delete [] __intbuf_;
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)
+ {
+     basic_streambuf<char_type, traits_type>::swap(__rhs);
+     if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
+     {
+         _VSTD::swap(__extbuf_, __rhs.__extbuf_);
+         _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);
+         _VSTD::swap(__extbufend_, __rhs.__extbufend_);
+     }
+     else
+     {
+         ptrdiff_t __ln = __extbufnext_ - __extbuf_;
+         ptrdiff_t __le = __extbufend_ - __extbuf_;
+         ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;
+         ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;
+         if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)
+         {
+             __extbuf_ = __rhs.__extbuf_;
+             __rhs.__extbuf_ = __rhs.__extbuf_min_;
+         }
+         else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)
+         {
+             __rhs.__extbuf_ = __extbuf_;
+             __extbuf_ = __extbuf_min_;
+         }
+         __extbufnext_ = __extbuf_ + __rn;
+         __extbufend_ = __extbuf_ + __re;
+         __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;
+         __rhs.__extbufend_ = __rhs.__extbuf_ + __le;
+     }
+     _VSTD::swap(__ebs_, __rhs.__ebs_);
+     _VSTD::swap(__intbuf_, __rhs.__intbuf_);
+     _VSTD::swap(__ibs_, __rhs.__ibs_);
+     _VSTD::swap(__file_, __rhs.__file_);
+     _VSTD::swap(__cv_, __rhs.__cv_);
+     _VSTD::swap(__st_, __rhs.__st_);
+     _VSTD::swap(__st_last_, __rhs.__st_last_);
+     _VSTD::swap(__om_, __rhs.__om_);
+     _VSTD::swap(__cm_, __rhs.__cm_);
+     _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);
+     _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);
+     _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);
+     if (this->eback() == (char_type*)__rhs.__extbuf_min_)
+     {
+         ptrdiff_t __n = this->gptr() - this->eback();
+         ptrdiff_t __e = this->egptr() - this->eback();
+         this->setg((char_type*)__extbuf_min_,
+                    (char_type*)__extbuf_min_ + __n,
+                    (char_type*)__extbuf_min_ + __e);
+     }
+     else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)
+     {
+         ptrdiff_t __n = this->pptr() - this->pbase();
+         ptrdiff_t __e = this->epptr() - this->pbase();
+         this->setp((char_type*)__extbuf_min_,
+                    (char_type*)__extbuf_min_ + __e);
+         this->pbump(__n);
+     }
+     if (__rhs.eback() == (char_type*)__extbuf_min_)
+     {
+         ptrdiff_t __n = __rhs.gptr() - __rhs.eback();
+         ptrdiff_t __e = __rhs.egptr() - __rhs.eback();
+         __rhs.setg((char_type*)__rhs.__extbuf_min_,
+                    (char_type*)__rhs.__extbuf_min_ + __n,
+                    (char_type*)__rhs.__extbuf_min_ + __e);
+     }
+     else if (__rhs.pbase() == (char_type*)__extbuf_min_)
+     {
+         ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();
+         ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();
+         __rhs.setp((char_type*)__rhs.__extbuf_min_,
+                    (char_type*)__rhs.__extbuf_min_ + __e);
+         __rhs.pbump(__n);
+     }
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ swap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)
+ {
+     __x.swap(__y);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ bool
+ basic_filebuf<_CharT, _Traits>::is_open() const
+ {
+     return __file_ != 0;
+ }
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>*
+ basic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
+ {
+     basic_filebuf<_CharT, _Traits>* __rt = 0;
+     if (__file_ == 0)
+     {
+         __rt = this;
+         const char* __mdstr;
+         switch (__mode & ~ios_base::ate)
+         {
+         case ios_base::out:
+         case ios_base::out | ios_base::trunc:
+             __mdstr = "w";
+             break;
+         case ios_base::out | ios_base::app:
+         case ios_base::app:
+             __mdstr = "a";
+             break;
+         case ios_base::in:
+             __mdstr = "r";
+             break;
+         case ios_base::in | ios_base::out:
+             __mdstr = "r+";
+             break;
+         case ios_base::in | ios_base::out | ios_base::trunc:
+             __mdstr = "w+";
+             break;
+         case ios_base::in | ios_base::out | ios_base::app:
+         case ios_base::in | ios_base::app:
+             __mdstr = "a+";
+             break;
+         case ios_base::out | ios_base::binary:
+         case ios_base::out | ios_base::trunc | ios_base::binary:
+             __mdstr = "wb";
+             break;
+         case ios_base::out | ios_base::app | ios_base::binary:
+         case ios_base::app | ios_base::binary:
+             __mdstr = "ab";
+             break;
+         case ios_base::in | ios_base::binary:
+             __mdstr = "rb";
+             break;
+         case ios_base::in | ios_base::out | ios_base::binary:
+             __mdstr = "r+b";
+             break;
+         case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:
+             __mdstr = "w+b";
+             break;
+         case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:
+         case ios_base::in | ios_base::app | ios_base::binary:
+             __mdstr = "a+b";
+             break;
+         default:
+             __rt = 0;
+             break;
+         }
+         if (__rt)
+         {
+             __file_ = fopen(__s, __mdstr);
+             if (__file_)
+             {
+                 __om_ = __mode;
+                 if (__mode & ios_base::ate)
+                 {
+                     if (fseek(__file_, 0, SEEK_END))
+                     {
+                         fclose(__file_);
+                         __file_ = 0;
+                         __rt = 0;
+                     }
+                 }
+             }
+             else
+                 __rt = 0;
+         }
+     }
+     return __rt;
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_filebuf<_CharT, _Traits>*
+ basic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
+ {
+     return open(__s.c_str(), __mode);
+ }
+ 
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>*
+ basic_filebuf<_CharT, _Traits>::open(FILE* fp, ios_base::openmode __mode)
+ {
+     basic_filebuf<_CharT, _Traits>* __rt = 0;
+     if (__file_ == 0)
+     {
+         __rt = this;
+         const char* __mdstr;
+         switch (__mode & ~ios_base::ate)
+         {
+         case ios_base::out:
+         case ios_base::out | ios_base::trunc:
+             __mdstr = "w";
+             break;
+         case ios_base::out | ios_base::app:
+         case ios_base::app:
+             __mdstr = "a";
+             break;
+         case ios_base::in:
+             __mdstr = "r";
+             break;
+         case ios_base::in | ios_base::out:
+             __mdstr = "r+";
+             break;
+         case ios_base::in | ios_base::out | ios_base::trunc:
+             __mdstr = "w+";
+             break;
+         case ios_base::in | ios_base::out | ios_base::app:
+         case ios_base::in | ios_base::app:
+             __mdstr = "a+";
+             break;
+         case ios_base::out | ios_base::binary:
+         case ios_base::out | ios_base::trunc | ios_base::binary:
+             __mdstr = "wb";
+             break;
+         case ios_base::out | ios_base::app | ios_base::binary:
+         case ios_base::app | ios_base::binary:
+             __mdstr = "ab";
+             break;
+         case ios_base::in | ios_base::binary:
+             __mdstr = "rb";
+             break;
+         case ios_base::in | ios_base::out | ios_base::binary:
+             __mdstr = "r+b";
+             break;
+         case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:
+             __mdstr = "w+b";
+             break;
+         case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:
+         case ios_base::in | ios_base::app | ios_base::binary:
+             __mdstr = "a+b";
+             break;
+         default:
+             __rt = 0;
+             break;
+         }
+         if (__rt)
+         {
+             __file_ = fp;
+             __fpflag = 1;
+             if (__file_)
+             {
+                 __om_ = __mode;
+                 if (__mode & ios_base::ate)
+                 {
+                     if (fseek(__file_, 0, SEEK_END))
+                     {
+                         fclose(__file_);
+                         __file_ = 0;
+                         __rt = 0;
+                     }
+                 }
+             }
+             else
+                 __rt = 0;
+         }
+     }
+     return __rt;
+ }
+ 
+ template <class _CharT, class _Traits>
+ basic_filebuf<_CharT, _Traits>*
+ basic_filebuf<_CharT, _Traits>::close()
+ {
+     basic_filebuf<_CharT, _Traits>* __rt = 0;
+     if (__file_ && !__fpflag)
+     {
+         __rt = this;
+         unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);
+         if (sync())
+             __rt = 0;
+         if (fclose(__h.release()) == 0)
+             __file_ = 0;
+         else
+             __rt = 0;
+ 
+     } else {
+       __file_ = 0;
+       __rt = 0;
+     }
+     return __rt;
+ }
+ template <class _CharT, class _Traits>
+ typename basic_filebuf<_CharT, _Traits>::int_type
+ basic_filebuf<_CharT, _Traits>::underflow()
+ {
+     if (__file_ == 0)
+         return traits_type::eof();
+     bool __initial = __read_mode();
+     char_type __1buf;
+     if (this->gptr() == 0)
+         this->setg(&__1buf, &__1buf+1, &__1buf+1);
+     const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
+     int_type __c = traits_type::eof();
+     if (this->gptr() == this->egptr())
+     {
+         memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));
+         if (__always_noconv_)
+         {
+             size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);
+             __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);
+             if (__nmemb != 0)
+             {
+                 this->setg(this->eback(),
+                            this->eback() + __unget_sz,
+                            this->eback() + __unget_sz + __nmemb);
+                 __c = traits_type::to_int_type(*this->gptr());
+             }
+         }
+         else
+         {
+             memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
+             __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
+             __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
+             size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),
+                                  static_cast<size_t>(__extbufend_ - __extbufnext_));
+             codecvt_base::result __r;
+             __st_last_ = __st_;
+             size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);
+             if (__nr != 0)
+             {
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+                 if (!__cv_)
+                     throw bad_cast();
+ #endif
+                 __extbufend_ = __extbufnext_ + __nr;
+                 char_type*  __inext;
+                 __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
+                                        this->eback() + __unget_sz,
+                                        this->eback() + __ibs_, __inext);
+                 if (__r == codecvt_base::noconv)
+                 {
+                     this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);
+                     __c = traits_type::to_int_type(*this->gptr());
+                 }
+                 else if (__inext != this->eback() + __unget_sz)
+                 {
+                     this->setg(this->eback(), this->eback() + __unget_sz, __inext);
+                     __c = traits_type::to_int_type(*this->gptr());
+                 }
+             }
+         }
+     }
+     else
+         __c = traits_type::to_int_type(*this->gptr());
+     if (this->eback() == &__1buf)
+         this->setg(0, 0, 0);
+     return __c;
+ }
+ 
+ template <class _CharT, class _Traits>
+ typename basic_filebuf<_CharT, _Traits>::int_type
+ basic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)
+ {
+     if (__file_ && this->eback() < this->gptr())
+     {
+         if (traits_type::eq_int_type(__c, traits_type::eof()))
+         {
+             this->gbump(-1);
+             return traits_type::not_eof(__c);
+         }
+         if ((__om_ & ios_base::out) ||
+             traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))
+         {
+             this->gbump(-1);
+             *this->gptr() = traits_type::to_char_type(__c);
+             return __c;
+         }
+     }
+     return traits_type::eof();
+ }
+ 
+ template <class _CharT, class _Traits>
+ typename basic_filebuf<_CharT, _Traits>::int_type
+ basic_filebuf<_CharT, _Traits>::overflow(int_type __c)
+ {
+     if (__file_ == 0)
+         return traits_type::eof();
+     __write_mode();
+     char_type __1buf;
+     char_type* __pb_save = this->pbase();
+     char_type* __epb_save = this->epptr();
+     if (!traits_type::eq_int_type(__c, traits_type::eof()))
+     {
+         if (this->pptr() == 0)
+             this->setp(&__1buf, &__1buf+1);
+         *this->pptr() = traits_type::to_char_type(__c);
+         this->pbump(1);
+     }
+     if (this->pptr() != this->pbase())
+     {
+         if (__always_noconv_)
+         {
+             size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
+             if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)
+                 return traits_type::eof();
+         }
+         else
+         {
+             char* __extbe = __extbuf_;
+             codecvt_base::result __r;
+             do
+             {
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+                 if (!__cv_)
+                     throw bad_cast();
+ #endif
+                 const char_type* __e;
+                 __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,
+                                         __extbuf_, __extbuf_ + __ebs_, __extbe);
+                 if (__e == this->pbase())
+                     return traits_type::eof();
+                 if (__r == codecvt_base::noconv)
+                 {
+                     size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());
+                     if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)
+                         return traits_type::eof();
+                 }
+                 else if (__r == codecvt_base::ok || __r == codecvt_base::partial)
+                 {
+                     size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
+                     if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
+                         return traits_type::eof();
+                     if (__r == codecvt_base::partial)
+                     {
+                         this->setp((char_type*)__e, this->pptr());
+                         this->pbump(this->epptr() - this->pbase());
+                     }
+                 }
+                 else
+                     return traits_type::eof();
+             } while (__r == codecvt_base::partial);
+         }
+         this->setp(__pb_save, __epb_save);
+     }
+     return traits_type::not_eof(__c);
+ }
+ 
+ template <class _CharT, class _Traits>
+ basic_streambuf<_CharT, _Traits>*
+ basic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)
+ {
+     this->setg(0, 0, 0);
+     this->setp(0, 0);
+     if (__owns_eb_)
+         delete [] __extbuf_;
+     if (__owns_ib_)
+         delete [] __intbuf_;
+     __ebs_ = __n;
+     if (__ebs_ > sizeof(__extbuf_min_))
+     {
+         if (__always_noconv_ && __s)
+         {
+             __extbuf_ = (char*)__s;
+             __owns_eb_ = false;
+         }
+         else
+         {
+             __extbuf_ = new char[__ebs_];
+             __owns_eb_ = true;
+         }
+     }
+     else
+     {
+         __extbuf_ = __extbuf_min_;
+         __ebs_ = sizeof(__extbuf_min_);
+         __owns_eb_ = false;
+     }
+     if (!__always_noconv_)
+     {
+         __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
+         if (__s && __ibs_ >= sizeof(__extbuf_min_))
+         {
+             __intbuf_ = __s;
+             __owns_ib_ = false;
+         }
+         else
+         {
+             __intbuf_ = new char_type[__ibs_];
+             __owns_ib_ = true;
+         }
+     }
+     else
+     {
+         __ibs_ = 0;
+         __intbuf_ = 0;
+         __owns_ib_ = false;
+     }
+     return this;
+ }
+ 
+ template <class _CharT, class _Traits>
+ typename basic_filebuf<_CharT, _Traits>::pos_type
+ basic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,
+                                         ios_base::openmode)
+ {
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+     if (!__cv_)
+         throw bad_cast();
+ #endif
+     int __width = __cv_->encoding();
+     if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())
+         return pos_type(off_type(-1));
+     // __width > 0 || __off == 0
+     int __whence;
+     switch (__way)
+     {
+     case ios_base::beg:
+         __whence = SEEK_SET;
+         break;
+     case ios_base::cur:
+         __whence = SEEK_CUR;
+         break;
+     case ios_base::end:
+         __whence = SEEK_END;
+         break;
+     default:
+         return pos_type(off_type(-1));
+     }
+ #if _WIN32
+     if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))
+         return pos_type(off_type(-1));
+     pos_type __r = ftell(__file_);
+ #else
+     if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))
+         return pos_type(off_type(-1));
+     pos_type __r = ftello(__file_);
+ #endif
+     __r.state(__st_);
+     return __r;
+ }
+ 
+ template <class _CharT, class _Traits>
+ typename basic_filebuf<_CharT, _Traits>::pos_type
+ basic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)
+ {
+     if (__file_ == 0 || sync())
+         return pos_type(off_type(-1));
+ #if _WIN32
+     if (fseek(__file_, __sp, SEEK_SET))
+         return pos_type(off_type(-1));
+ #else
+     if (fseeko(__file_, __sp, SEEK_SET))
+         return pos_type(off_type(-1));
+ #endif
+     __st_ = __sp.state();
+     return __sp;
+ }
+ 
+ template <class _CharT, class _Traits>
+ int
+ basic_filebuf<_CharT, _Traits>::sync()
+ {
+     if (__file_ == 0)
+         return 0;
+ #ifndef _LIBCPP_NO_EXCEPTIONS
+     if (!__cv_)
+         throw bad_cast();
+ #endif
+     if (__cm_ & ios_base::out)
+     {
+         if (this->pptr() != this->pbase())
+             if (overflow() == traits_type::eof())
+                 return -1;
+         codecvt_base::result __r;
+         do
+         {
+             char* __extbe;
+             __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
+             size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);
+             if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)
+                 return -1;
+         } while (__r == codecvt_base::partial);
+         if (__r == codecvt_base::error)
+             return -1;
+         if (fflush(__file_))
+             return -1;
+     }
+     else if (__cm_ & ios_base::in)
+     {
+         off_type __c;
+         state_type __state = __st_last_;
+         bool __update_st = false;
+         if (__always_noconv_)
+             __c = this->egptr() - this->gptr();
+         else
+         {
+             int __width = __cv_->encoding();
+             __c = __extbufend_ - __extbufnext_;
+             if (__width > 0)
+                 __c += __width * (this->egptr() - this->gptr());
+             else
+             {
+                 if (this->gptr() != this->egptr())
+                 {
+                     const int __off =  __cv_->length(__state, __extbuf_,
+                                                      __extbufnext_,
+                                                      this->gptr() - this->eback());
+                     __c += __extbufnext_ - __extbuf_ - __off;
+                     __update_st = true;
+                 }
+             }
+         }
+ #if _WIN32
+         if (fseek(__file_, -__c, SEEK_CUR))
+             return -1;
+ #else
+         if (fseeko(__file_, -__c, SEEK_CUR))
+             return -1;
+ #endif
+         if (__update_st)
+             __st_ = __state;
+         __extbufnext_ = __extbufend_ = __extbuf_;
+         this->setg(0, 0, 0);
+         __cm_ = 0;
+     }
+     return 0;
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)
+ {
+     sync();
+     __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);
+     bool __old_anc = __always_noconv_;
+     __always_noconv_ = __cv_->always_noconv();
+     if (__old_anc != __always_noconv_)
+     {
+         this->setg(0, 0, 0);
+         this->setp(0, 0);
+         // invariant, char_type is char, else we couldn't get here
+         if (__always_noconv_)  // need to dump __intbuf_
+         {
+             if (__owns_eb_)
+                 delete [] __extbuf_;
+             __owns_eb_ = __owns_ib_;
+             __ebs_ = __ibs_;
+             __extbuf_ = (char*)__intbuf_;
+             __ibs_ = 0;
+             __intbuf_ = 0;
+             __owns_ib_ = false;
+         }
+         else  // need to obtain an __intbuf_.
+         {     // If __extbuf_ is user-supplied, use it, else new __intbuf_
+             if (!__owns_eb_ && __extbuf_ != __extbuf_min_)
+             {
+                 __ibs_ = __ebs_;
+                 __intbuf_ = (char_type*)__extbuf_;
+                 __owns_ib_ = false;
+                 __extbuf_ = new char[__ebs_];
+                 __owns_eb_ = true;
+             }
+             else
+             {
+                 __ibs_ = __ebs_;
+                 __intbuf_ = new char_type[__ibs_];
+                 __owns_ib_ = true;
+             }
+         }
+     }
+ }
+ 
+ template <class _CharT, class _Traits>
+ bool
+ basic_filebuf<_CharT, _Traits>::__read_mode()
+ {
+     if (!(__cm_ & ios_base::in))
+     {
+         this->setp(0, 0);
+         if (__always_noconv_)
+             this->setg((char_type*)__extbuf_,
+                        (char_type*)__extbuf_ + __ebs_,
+                        (char_type*)__extbuf_ + __ebs_);
+         else
+             this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
+         __cm_ = ios_base::in;
+         return true;
+     }
+     return false;
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_filebuf<_CharT, _Traits>::__write_mode()
+ {
+     if (!(__cm_ & ios_base::out))
+     {
+         this->setg(0, 0, 0);
+         if (__ebs_ > sizeof(__extbuf_min_))
+         {
+             if (__always_noconv_)
+                 this->setp((char_type*)__extbuf_,
+                            (char_type*)__extbuf_ + (__ebs_ - 1));
+             else
+                 this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
+         }
+         else
+             this->setp(0, 0);
+         __cm_ = ios_base::out;
+     }
+ }
+ 
+ // basic_ifstream
+ 
+ template <class _CharT, class _Traits>
+ class _LIBCPP_TYPE_VIS_ONLY basic_ifstream
+     : public basic_istream<_CharT, _Traits>
+ {
+ public:
+     typedef _CharT                         char_type;
+     typedef _Traits                        traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_ifstream();
+     explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);
+     explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_ifstream(basic_ifstream&& __rhs);
+ #endif
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_ifstream& operator=(basic_ifstream&& __rhs);
+ #endif
+     void swap(basic_ifstream& __rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* __s, ios_base::openmode __mode = ios_base::in);
+     void open(const string& __s, ios_base::openmode __mode = ios_base::in);
+     void open(int fd, ios_base::openmode __mode = ios_base::in);
+     void close();
+ 
+ private:
+     basic_filebuf<char_type, traits_type> __sb_;
+ };
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ifstream<_CharT, _Traits>::basic_ifstream()
+     : basic_istream<char_type, traits_type>(&__sb_)
+ {
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)
+     : basic_istream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode | ios_base::in) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)
+     : basic_istream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode | ios_base::in) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)
+     : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),
+       __sb_(_VSTD::move(__rhs.__sb_))
+ {
+     this->set_rdbuf(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ifstream<_CharT, _Traits>&
+ basic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)
+ {
+     basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
+     __sb_ = _VSTD::move(__rhs.__sb_);
+     return *this;
+ }
+ 
+ #endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)
+ {
+     basic_istream<char_type, traits_type>::swap(__rhs);
+     __sb_.swap(__rhs.__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ swap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)
+ {
+     __x.swap(__y);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_filebuf<_CharT, _Traits>*
+ basic_ifstream<_CharT, _Traits>::rdbuf() const
+ {
+     return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ bool
+ basic_ifstream<_CharT, _Traits>::is_open() const
+ {
+     return __sb_.is_open();
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode | ios_base::in))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode | ios_base::in))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ifstream<_CharT, _Traits>::open(int fd, ios_base::openmode __mode)
+ {
+     if (__sb_.open(fd, __mode | ios_base::in))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_ifstream<_CharT, _Traits>::close()
+ {
+     if (__sb_.close() == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ // basic_ofstream
+ 
+ template <class _CharT, class _Traits>
+ class _LIBCPP_TYPE_VIS_ONLY basic_ofstream
+     : public basic_ostream<_CharT, _Traits>
+ {
+ public:
+     typedef _CharT                         char_type;
+     typedef _Traits                        traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_ofstream();
+     explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);
+     explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_ofstream(basic_ofstream&& __rhs);
+ #endif
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_ofstream& operator=(basic_ofstream&& __rhs);
+ #endif
+     void swap(basic_ofstream& __rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* __s, ios_base::openmode __mode = ios_base::out);
+     void open(const string& __s, ios_base::openmode __mode = ios_base::out);
+     void open(int fd, ios_base::openmode __mode = ios_base::out);
+     void close();
+ 
+ private:
+     basic_filebuf<char_type, traits_type> __sb_;
+ };
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ofstream<_CharT, _Traits>::basic_ofstream()
+     : basic_ostream<char_type, traits_type>(&__sb_)
+ {
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)
+     : basic_ostream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode | ios_base::out) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)
+     : basic_ostream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode | ios_base::out) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)
+     : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),
+       __sb_(_VSTD::move(__rhs.__sb_))
+ {
+     this->set_rdbuf(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_ofstream<_CharT, _Traits>&
+ basic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)
+ {
+     basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
+     __sb_ = _VSTD::move(__rhs.__sb_);
+     return *this;
+ }
+ 
+ #endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)
+ {
+     basic_ostream<char_type, traits_type>::swap(__rhs);
+     __sb_.swap(__rhs.__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ swap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)
+ {
+     __x.swap(__y);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_filebuf<_CharT, _Traits>*
+ basic_ofstream<_CharT, _Traits>::rdbuf() const
+ {
+     return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ bool
+ basic_ofstream<_CharT, _Traits>::is_open() const
+ {
+     return __sb_.is_open();
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode | ios_base::out))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode | ios_base::out))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_ofstream<_CharT, _Traits>::open(int fd, ios_base::openmode __mode)
+ {
+     if (__sb_.open(fd, __mode | ios_base::out))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_ofstream<_CharT, _Traits>::close()
+ {
+     if (__sb_.close() == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ // basic_fstream
+ 
+ template <class _CharT, class _Traits>
+ class _LIBCPP_TYPE_VIS_ONLY basic_fstream
+     : public basic_iostream<_CharT, _Traits>
+ {
+ public:
+     typedef _CharT                         char_type;
+     typedef _Traits                        traits_type;
+     typedef typename traits_type::int_type int_type;
+     typedef typename traits_type::pos_type pos_type;
+     typedef typename traits_type::off_type off_type;
+ 
+     basic_fstream();
+     explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
+     explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
+     explicit basic_fstream(int fd, ios_base::openmode __mode = ios_base::in | ios_base::out);
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_fstream(basic_fstream&& __rhs);
+ #endif
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+     basic_fstream& operator=(basic_fstream&& __rhs);
+ #endif
+     void swap(basic_fstream& __rhs);
+ 
+     basic_filebuf<char_type, traits_type>* rdbuf() const;
+     bool is_open() const;
+     void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
+     void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);
+     void open(int fd, ios_base::openmode __mode = ios_base::in | ios_base::out);
+     void close();
+ 
+ private:
+     basic_filebuf<char_type, traits_type> __sb_;
+ };
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>::basic_fstream()
+     : basic_iostream<char_type, traits_type>(&__sb_)
+ {
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)
+     : basic_iostream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)
+     : basic_iostream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(__s, __mode) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>::basic_fstream(int fd, ios_base::openmode __mode)
+     : basic_iostream<char_type, traits_type>(&__sb_)
+ {
+     if (__sb_.open(fd, __mode) == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ #ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)
+     : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),
+       __sb_(_VSTD::move(__rhs.__sb_))
+ {
+     this->set_rdbuf(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_fstream<_CharT, _Traits>&
+ basic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)
+ {
+     basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));
+     __sb_ = _VSTD::move(__rhs.__sb_);
+     return *this;
+ }
+ 
+ #endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)
+ {
+     basic_iostream<char_type, traits_type>::swap(__rhs);
+     __sb_.swap(__rhs.__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ swap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)
+ {
+     __x.swap(__y);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ basic_filebuf<_CharT, _Traits>*
+ basic_fstream<_CharT, _Traits>::rdbuf() const
+ {
+     return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ bool
+ basic_fstream<_CharT, _Traits>::is_open() const
+ {
+     return __sb_.is_open();
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)
+ {
+     if (__sb_.open(__s, __mode))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ void
+ basic_fstream<_CharT, _Traits>::open(int fd, ios_base::openmode __mode)
+ {
+     if (__sb_.open(fd, __mode))
+         this->clear();
+     else
+         this->setstate(ios_base::failbit);
+ }
+ 
+ template <class _CharT, class _Traits>
+ inline _LIBCPP_INLINE_VISIBILITY
+ void
+ basic_fstream<_CharT, _Traits>::close()
+ {
+     if (__sb_.close() == 0)
+         this->setstate(ios_base::failbit);
+ }
+ 
+ _LIBCPP_END_NAMESPACE_STD
+ 
+ #endif  // _LIBCPP_FSTREAM
+ #endif  // defined(__APPLE__)
*** ./ivtools-1.2/src/include/ivstd/fstream.h.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/include/ivstd/fstream.h	2015-01-25 16:56:24.000000000 -0800
***************
*** 1,10 ****
  #ifndef _iv_fstream_
  #define _iv_fstream_
! #include_next <fstream>
  #if __GNUC__>=3
  #define input ios_base::in
  #define output ios_base::out
! #if __GNUC__>3 || __GNUC__==3 && __GNUC_MINOR__>0 /* && !defined(__APPLE__) */
  #include <ext/stdio_filebuf.h>
  #define fileptr_filebuf __gnu_cxx::stdio_filebuf<char>
  #else
--- 1,10 ----
  #ifndef _iv_fstream_
  #define _iv_fstream_
! #include <fstream>
  #if __GNUC__>=3
  #define input ios_base::in
  #define output ios_base::out
! #if (__GNUC__>3 || __GNUC__==3 && __GNUC_MINOR__>0) && !defined(__APPLE__)
  #include <ext/stdio_filebuf.h>
  #define fileptr_filebuf __gnu_cxx::stdio_filebuf<char>
  #else
***************
*** 14,17 ****
--- 14,30 ----
  #define input "r"
  #define output "w"
  #endif
+ #ifndef __APPLE__
+ #define FILEBUF(bufname, fptr, mode)		\
+      fileptr_filebuf bufname(fptr, mode)
+ #define FILEBUFP(bufname, fptr, mode)	\
+      fileptr_filebuf* bufname = new fileptr_filebuf(fptr, mode)
+ #else
+ #define FILEBUF(bufname, fptr, mode)		\
+      fileptr_filebuf bufname; \
+      bufname.open(fptr, mode); 
+ #define FILEBUFP(bufname, fptr, mode) \
+      fileptr_filebuf* bufname = new fileptr_filebuf; \
+      bufname -> open(fptr,mode);
+ #endif
  #endif
*** ./ivtools-1.2/src/include/ivstd/Imakefile.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/include/ivstd/Imakefile	2015-01-22 12:46:54.000000000 -0800
***************
*** 8,11 ****
--- 8,12 ----
  
  InstallIncludes(ivstd)
  InstallInclude(ivstd,iosfwd)
+ InstallInclude(ivstd,fstream)
  
*** ./ivtools-1.2/src/OverlayUnidraw/aceimport.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/OverlayUnidraw/aceimport.c	2015-01-25 17:39:56.000000000 -0800
***************
*** 80,107 ****
  int
  UnidrawImportHandler::handle_input (ACE_HANDLE fd)
  {
- #if 0
-     if (!_inptr) {
-         _filebuf = new filebuf();
- 	boolean valid = _filebuf->attach(fd) != 0;
- 	_inptr = new istream(_filebuf);
-         _import_cmd->instream(_inptr);
-     }
-     int ch;
-     ch = _inptr->get();
-     if (ch != EOF && _inptr->good()) {
-       _inptr->putback(ch);
-       _import_cmd->Execute();
-     }
-     return _inptr->good() ? 0 : -1;
- #else
- #if __GNUC__<3
-     filebuf fbuf;
-     if(fbuf.attach(fd)==0) return -1;
- #else
      if (!_infptr) _infptr = fdopen(fd, "r");
!     fileptr_filebuf fbuf(_infptr, ios_base::in);
! #endif
      istream in(&fbuf);
      int ch = in.get();
      if (ch != EOF && in.good()) {
--- 80,87 ----
  int
  UnidrawImportHandler::handle_input (ACE_HANDLE fd)
  {
      if (!_infptr) _infptr = fdopen(fd, "r");
!     FILEBUF(fbuf, _infptr, ios_base::in);
      istream in(&fbuf);
      int ch = in.get();
      if (ch != EOF && in.good()) {
***************
*** 110,116 ****
        _import_cmd->Execute();
      }
      return -1;  /* only return -1, which indicates input handling is fini */
- #endif
  }
  
  int
--- 90,95 ----
*** ./ivtools-1.2/src/OverlayUnidraw/ovcatalog.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/OverlayUnidraw/ovcatalog.c	2015-01-25 17:33:33.000000000 -0800
***************
*** 188,209 ****
          _valid = true;
  
      } else {
- #if __GNUC__<3	  
-         filebuf fbuf;
- 	if (strcmp(name, "-") == 0) {
- 	    _valid = fbuf.attach(fileno(stdin)) != 0;
- 	    name = nil;
- 	} else {
- 	    fptr = fopen(name, "r");
- 	    fptr = OvImportCmd::CheckCompression(fptr, name, compressed);
- 	    _valid = fptr ? fbuf.attach(fileno(fptr)) != 0 : false;
- 	    if (compressed) {
- 		int namelen = strlen(name);
- 		if (strcmp(name+namelen-3,".gz")==0) name[namelen-3] = '\0';
- 		else if (strcmp(name+namelen-2,".Z")==0) name[namelen-2] = '\0';
- 	    }
- 	}
- #else
  	boolean stdin_flag = strcmp(name, "-")==0;
  	if (!stdin_flag) {
  	  fptr = fopen(name, "r");
--- 188,193 ----
***************
*** 219,226 ****
  	  name = nil;
  	}
  	if (!_valid && !ParamList::urltest(name)) return false;
!         fileptr_filebuf fbuf(stdin_flag ? stdin : fptr, ios_base::in);
! #endif
  	
          if (_valid || ParamList::urltest(name)) {
  	    istream in(&fbuf);
--- 203,209 ----
  	  name = nil;
  	}
  	if (!_valid && !ParamList::urltest(name)) return false;
!         FILEBUF(fbuf, stdin_flag ? stdin : fptr, ios_base::in);
  	
          if (_valid || ParamList::urltest(name)) {
  	    istream in(&fbuf);
*** ./ivtools-1.2/src/OverlayUnidraw/ovfile.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/OverlayUnidraw/ovfile.c	2015-01-25 17:34:11.000000000 -0800
***************
*** 223,235 ****
        OvImportCmd impcmd((Editor*)nil);
        FILE* fptr = popen(pathname, "r");
        if (fptr) {
! #if __GNUC__<3
! 	ifstream ifs;
! 	ifs.rdbuf()->attach(fileno(fptr));
! #else
! 	fileptr_filebuf fbuf(fptr, ios_base::in);
  	istream ifs(&fbuf);
- #endif
  	OverlayComp* child = (OverlayComp*) impcmd.Import(ifs);
  	if (child) {
  	  filecomp->Append(child);
--- 223,230 ----
        OvImportCmd impcmd((Editor*)nil);
        FILE* fptr = popen(pathname, "r");
        if (fptr) {
! 	FILEBUF(fbuf, fptr, ios_base::in);
  	istream ifs(&fbuf);
  	OverlayComp* child = (OverlayComp*) impcmd.Import(ifs);
  	if (child) {
  	  filecomp->Append(child);
*** ./ivtools-1.2/src/OverlayUnidraw/ovimport.c.dist	2015-01-27 13:46:30.000000000 -0800
--- ./ivtools-1.2/src/OverlayUnidraw/ovimport.c	2015-01-25 17:38:34.000000000 -0800
***************
*** 121,129 ****
  implementPtrList(StreamList,istream)
  implementPtrList(HandlerList,ReadImageHandler)
  
- #if __GNUC__>=3
  static char newline;
- #endif
  
  
  /*****************************************************************************/
--- 121,127 ----
***************
*** 467,480 ****
  
      if (pos >= 0) { 
  
- #if __GNUC__<3
-       char* buffer;
-       in.gets(&buffer);
- #else
        char buffer[BUFSIZ];
        in.get(buffer, BUFSIZ);
        in.get(newline);
- #endif
  
        if (strncmp(buffer, "P6", 2)) {
          cerr << "only binary ppms (magic P6) supported at this time" << endl;
--- 465,473 ----
***************
*** 483,503 ****
  
        u_long width, height;
        do { 
- #if __GNUC__<3	
-         in.gets(&buffer);
- #else
  	in.get(buffer,BUFSIZ);
  	in.get(newline);
- #endif
        } while (buffer[0] == '#');
        sscanf(buffer, "%d %d", &width, &height);
  
- #if __GNUC__<3	
-       in.gets(&buffer);
- #else
        in.get(buffer,BUFSIZ);
        in.get(newline);
- #endif
        int maxval;
        sscanf(buffer, "%d", &maxval);
        if (maxval != 255) {
--- 476,488 ----
***************
*** 604,621 ****
  
      clr_fl(_fd, O_NONBLOCK);
  
- #if __GNUC__<3
-     ifstream* ifs = new ifstream;
-     ifs->rdbuf()->attach(_fd);
- #else
      FILE* ifptr = fdopen(_fd, "r");
!     fileptr_filebuf* fbuf = new fileptr_filebuf(ifptr, ios_base::in);
      istream* ifs = new istream(fbuf);
- #endif
      _helper.add_stream(ifs);
- #if __GNUC__>=3
      _helper.add_file(ifptr);
- #endif
      boolean empty;
  
      int newfd;
--- 589,599 ----
  
      clr_fl(_fd, O_NONBLOCK);
  
      FILE* ifptr = fdopen(_fd, "r");
!     FILEBUFP(fbuf,ifptr, ios_base::in);
      istream* ifs = new istream(fbuf);
      _helper.add_stream(ifs);
      _helper.add_file(ifptr);
      boolean empty;
  
      int newfd;
***************
*** 1098,1110 ****
        } else if (!is_url()) {
  	fptr = popen(path_, "r");
  	if (fptr) {
! #if __GNUC__<3
! 	  ifstream* ifs = new ifstream;
!           ifs->rdbuf()->attach(fileno(fptr));
! #else
! 	  fileptr_filebuf* fbuf = new fileptr_filebuf(fptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
- #endif
  	  inptr_ = ifs;
  	}
        }	
--- 1076,1083 ----
        } else if (!is_url()) {
  	fptr = popen(path_, "r");
  	if (fptr) {
! 	  FILEBUFP(fbuf, fptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
  	  inptr_ = ifs;
  	}
        }	
***************
*** 1407,1419 ****
      
  
      if (fptr) {
! #if __GNUC__<3
!       ifstream* in = new ifstream;
!       in->rdbuf()->attach(fileno(fptr));
! #else
!       fileptr_filebuf* fbuf = new fileptr_filebuf(fptr, ios_base::in);
        istream* in = new istream(fbuf);
- #endif
        helper_->add_stream(in);
  
        if ((chooser_ && (chooser_->auto_convert() || chooser_->from_command())))
--- 1380,1387 ----
      
  
      if (fptr) {
!       FILEBUFP(fbuf, fptr, ios_base::in);
        istream* in = new istream(fbuf);
        helper_->add_stream(in);
  
        if ((chooser_ && (chooser_->auto_convert() || chooser_->from_command())))
***************
*** 1496,1523 ****
  	gunzip_fptr = popen(buffer, "r");
          helper.add_pipe(gunzip_fptr);
  	if (gunzip_fptr) {
! #if __GNUC__<3
! 	  ifstream* ifs = new ifstream;
!           ifs->rdbuf()->attach(fileno(gunzip_fptr));
! #else
! 	  fileptr_filebuf* fbuf = new fileptr_filebuf(gunzip_fptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
- #endif
            helper.add_stream(ifs);
  	  in = gunzip_in = ifs;
  	}
        } else {
  	int newfd = Pipe_Filter(instrm, "gunzip -c");
  	if (newfd != -1) {
- #if __GNUC__<3
- 	  ifstream* ifs = new ifstream;
-           ifs->rdbuf()->attach(newfd);
- #else
  	  FILE* ifptr = fdopen(newfd, "r");
! 	  fileptr_filebuf* fbuf = new fileptr_filebuf(ifptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
  	  helper.add_file(ifptr);
- #endif
  	  helper.add_stream(ifs);
  	  in = gunzip_in = ifs;
  	}
--- 1464,1481 ----
  	gunzip_fptr = popen(buffer, "r");
          helper.add_pipe(gunzip_fptr);
  	if (gunzip_fptr) {
! 	  FILEBUFP(fbuf, gunzip_fptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
            helper.add_stream(ifs);
  	  in = gunzip_in = ifs;
  	}
        } else {
  	int newfd = Pipe_Filter(instrm, "gunzip -c");
  	if (newfd != -1) {
  	  FILE* ifptr = fdopen(newfd, "r");
! 	  FILEBUFP(fbuf, ifptr, ios_base::in);
  	  istream* ifs = new istream(fbuf);
  	  helper.add_file(ifptr);
  	  helper.add_stream(ifs);
  	  in = gunzip_in = ifs;
  	}
***************
*** 1556,1570 ****
  	      new_fd = fileno(pptr);
  	  } else 
  	    new_fd = Pipe_Filter(*in, "tf=`tempname`;pstoedit -f idraw - $tf.%d;cat $tf.*;rm $tf.*");
- #if __GNUC__<3
- 	  ifstream new_in;
-           new_in.rdbuf()->attach(new_fd);
- #else
  	  FILE* ifptr = fdopen(new_fd, "r");
  	  helper.add_file(ifptr);
! 	  fileptr_filebuf fbuf(ifptr, ios_base::in);
  	  istream new_in(&fbuf);
- #endif
  	  comp = catalog->ReadPostScript(new_in);
  	  if (pptr) pclose(pptr);
  	} else
--- 1514,1523 ----
  	      new_fd = fileno(pptr);
  	  } else 
  	    new_fd = Pipe_Filter(*in, "tf=`tempname`;pstoedit -f idraw - $tf.%d;cat $tf.*;rm $tf.*");
  	  FILE* ifptr = fdopen(new_fd, "r");
  	  helper.add_file(ifptr);
! 	  FILEBUF(fbuf, ifptr, ios_base::in);
  	  istream new_in(&fbuf);
  	  comp = catalog->ReadPostScript(new_in);
  	  if (pptr) pclose(pptr);
  	} else
***************
*** 1594,1606 ****
  	  FILE* pptr = popen(buffer, "r");
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! #if __GNUC__<3
! 	    ifstream new_in;
!             new_in.rdbuf()->attach(fileno(pptr));
! #else
! 	    fileptr_filebuf fbuf(pptr, ios_base::in);
  	    istream new_in(&fbuf);
- #endif
  	    comp = PNM_Image(new_in);
  	    pclose(pptr);
  	  }
--- 1547,1554 ----
  	  FILE* pptr = popen(buffer, "r");
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! 	    FILEBUF(fbuf, pptr, ios_base::in);
  	    istream new_in(&fbuf);
  	    comp = PNM_Image(new_in);
  	    pclose(pptr);
  	  }
***************
*** 1659,1671 ****
            helper.add_pipe(pptr);
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! #if __GNUC__<3
! 	    ifstream* new_in = new ifstream;
!             new_in->rdbuf()->attach(fileno(pptr));
! #else
! 	    fileptr_filebuf* fbuf = new fileptr_filebuf(pptr, ios_base::in);
  	    istream* new_in = new istream(fbuf);
- #endif
              helper.add_stream(new_in);
  	    comp = PNM_Image(*new_in);
  	  }
--- 1607,1614 ----
            helper.add_pipe(pptr);
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! 	    FILEBUFP(fbuf, pptr, ios_base::in);
  	    istream* new_in = new istream(fbuf);
              helper.add_stream(new_in);
  	    comp = PNM_Image(*new_in);
  	  }
***************
*** 1689,1701 ****
  	  FILE* pptr = popen(buffer, "r");
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! #if __GNUC__<3
! 	    ifstream new_in;
!             new_in.rdbuf()->attach(fileno(pptr));
! #else
! 	    fileptr_filebuf fbuf(pptr, ios_base::in);
  	    istream new_in(&fbuf);
- #endif
  	    comp = PNM_Image(new_in);
  	    pclose(pptr);
  	  }
--- 1632,1639 ----
  	  FILE* pptr = popen(buffer, "r");
  	  if (pptr) {
  	    cerr << "input opened with " << buffer << "\n";
! 	    FILEBUF(fbuf, pptr, ios_base::in);
  	    istream new_in(&fbuf);
  	    comp = PNM_Image(new_in);
  	    pclose(pptr);
  	  }
***************
*** 1952,1990 ****
  
  OverlayRaster* OvImportCmd::PGM_Raster (istream& in, boolean ascii) {
   
- #if __GNUC__<3 
-     char* buffer;
-     in.gets(&buffer);
- #else
      char buffer[BUFSIZ];
      in.get(buffer, BUFSIZ);
      in.get(newline);
- #endif
  
      do {  // CREATOR and other comments
- #if __GNUC__<3 
-         in.gets(&buffer);
- #else
  	in.get(buffer, BUFSIZ);
  	in.get(newline);
- #endif
      } while (buffer[0] == '#');
  
      int nrows, ncols;
      if (sscanf(buffer, "%d %d", &ncols, &nrows)==1) {
- #if __GNUC__<3 
-           in.gets(&buffer);
- #else
  	  in.get(buffer, BUFSIZ);
  	  in.get(newline);
- #endif
            sscanf(buffer, "%d", &nrows);
      }
- #if __GNUC__<3 
-     in.gets(&buffer);
- #else
      in.get(buffer, BUFSIZ, '\n');
- #endif
      int maxval;
      sscanf(buffer, "%d", &maxval);
  
--- 1890,1911 ----
***************
*** 2390,2420 ****
  
  
  OverlayRaster* OvImportCmd::PPM_Raster (istream& in, boolean ascii) {
- #if __GNUC__<3
-     char* buffer;
-     in.gets(&buffer); // read magic number
- #else
      char buffer[BUFSIZ];
      in.get(buffer,BUFSIZ);
      in.get(newline);
- #endif
  
      do { // CREATOR and other comments
- #if __GNUC__<3
-         in.gets(&buffer);
- #else
  	in.get(buffer,BUFSIZ);
  	in.get(newline);
- #endif
      } while (buffer[0] == '#');
      int nrows, ncols;
      sscanf(buffer, "%d %d", &ncols, &nrows);
- #if __GNUC__<3
-     in.gets(&buffer);
- #else
      in.get(buffer,BUFSIZ);
      in.get(newline);
- #endif
      int maxval;
      sscanf(buffer, "%d", &maxval);
      if (maxval != 255) {
--- 2311,2328 ----
***************
*** 2459,2480 ****
      fd = outfd;
    }
    else {
- #if __GNUC__<3    
-     ifstream in2;
-     in2.rdbuf()->attach(outfd);
- #else
      FILE* infptr = fdopen(outfd, "r");
!     fileptr_filebuf fbuf(infptr, ios_base::in);
      istream in2(&fbuf);
- #endif
  
      comp = PNM_Image(in2);
  
      if(close(outfd)==-1)
        cerr << "error in parent closing last end of the pipes\n";
- #if __GNUC__>=3
      if (infptr) fclose(infptr);
- #endif
    }
  
    return comp;
--- 2367,2381 ----
      fd = outfd;
    }
    else {
      FILE* infptr = fdopen(outfd, "r");
!     FILEBUF(fbuf, infptr, ios_base::in);
      istream in2(&fbuf);
  
      comp = PNM_Image(in2);
  
      if(close(outfd)==-1)
        cerr << "error in parent closing last end of the pipes\n";
      if (infptr) fclose(infptr);
    }
  
    return comp;
***************
*** 2536,2559 ****
      } else
        if(close(pipe1[0])==-1) 
  	cerr << "error in child close of front end of pipe\n";
- #if __GNUC__<3
-     ofstream out;
-     out.rdbuf()->attach(pipe1[1]);
-     char buffer[BUFSIZ];
-     while (!in.eof() && in.good()) {
-       in.read(buffer, BUFSIZ);
-       if (!in.eof() || in.gcount())
- 	out.write(buffer, in.gcount());
-     }
-     out.flush();
- #else
      char buffer[BUFSIZ];
      while (!in.eof() && in.good()) {
        in.read(buffer, BUFSIZ);
        if (!in.eof() || in.gcount())
  	write(pipe1[1], buffer, in.gcount());
      }
- #endif
      if(close(pipe1[1])==-1)
        cerr << "error in child closing its output pipe\n";
      int status;
--- 2437,2448 ----
***************
*** 2717,2750 ****
  Bitmap* OvImportCmd::PBM_Bitmap (istream& in) {
      Bitmap* bitmap = nil;
    
- #if __GNUC__<3
-     char* buffer;
-     in.gets(&buffer);
- #else
      char buffer[BUFSIZ];
      in.get(buffer,BUFSIZ);
      in.get(newline);
- #endif
  
      boolean asciiflag = strncmp("P1", buffer, 2) == 0;
    
      do { // CREATOR and other comments
- #if __GNUC__<3
-         in.gets(&buffer);
- #else
  	in.get(buffer,BUFSIZ);
  	in.get(newline);
- #endif
      } while (buffer[0] == '#');
  
      int nrows, ncols;
      if (sscanf(buffer, "%d %d", &ncols, &nrows)==1) {
- #if __GNUC__<3
-           in.gets(&buffer);
- #else
  	  in.get(buffer,BUFSIZ);
  	  in.get(newline);
- #endif
            sscanf(buffer, "%d", &nrows);
      }
      void* nilpointer = nil;
--- 2606,2626 ----
*** ivtools-1.2/COPYRIGHT.dist	2015-01-29 08:19:09.000000000 -0800
--- ivtools-1.2/COPYRIGHT	2015-01-29 08:18:12.000000000 -0800
***************
*** 1,5 ****
  /*
!  * Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Scott E. Johnston
   * Copyright (c) 2000  Vectaport Inc., IET Inc
   * Copyright (c) 1999  Vectaport Inc., IET Inc, R.B. Kissh and Associates
   * Copyright (c) 1998  Vectaport Inc., R.B. Kissh and Associates, Eric F. Kahler
--- 1,7 ----
  /*
!  * Copyright (c) 2014-2015 Scott E. Johnston
!  * Copyright (c) 2009-2014 Wave Semiconductor Inc.
!  * Copyright (c) 2001-2009 Scott E. Johnston
   * Copyright (c) 2000  Vectaport Inc., IET Inc
   * Copyright (c) 1999  Vectaport Inc., IET Inc, R.B. Kissh and Associates
   * Copyright (c) 1998  Vectaport Inc., R.B. Kissh and Associates, Eric F. Kahler
*** ivtools-1.2/config/arch.def.dist	2015-01-29 08:57:29.000000000 -0800
--- ivtools-1.2/config/arch.def	2015-01-29 08:57:50.000000000 -0800
***************
*** 8,20 ****
  #define NO 0
  #define NullParameter /**/
  
! #if __STDC__ && !defined(__CYGWIN__)
  #define Concat(a,b)a##b
  #else
  #define Concat(a,b)a/**/b
  #endif
  
! #if __STDC__ && !defined(__CYGWIN__)
  #define Concat3(a,b,c)a##b##c
  #else
  #define Concat3(a,b,c)a/**/b/**/c
--- 8,20 ----
  #define NO 0
  #define NullParameter /**/
  
! #if __STDC__ && !defined(__CYGWIN__) || defined(__APPLE__)
  #define Concat(a,b)a##b
  #else
  #define Concat(a,b)a/**/b
  #endif
  
! #if __STDC__ && !defined(__CYGWIN__) || defined(__APPLE__)
  #define Concat3(a,b,c)a##b##c
  #else
  #define Concat3(a,b,c)a/**/b/**/c
